# 数据结构与算法

## 什么是栈

栈是一种线性表，其限制只能在表尾进行插入或删除操作。由于该特性又称为后进先出的线性表。

## 什么是队列

队列是一种先进先出的线性表。其限制只能在线性表的一端进行插入，而在另一端删除元素。

## 什么是二叉树

二叉树是 n 个有限元素的集合，该集合或者为空、或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。

## 什么是满二叉树

一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。

## 什么是完全二叉树

一棵深度为 `k` 的有 `n` 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号。

如果编号为 `i` 的结点与满二叉树中编号为 `i` 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

## 什么是二叉查找树

二叉排序树（Binary Sort Tree）又称二叉查找树、二叉搜索树。

它或者是一棵空树，或者是具有下列性质的二叉树：

- 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。
- 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。
- 左、右子树也分别为二叉排序树。

原理：

- 若根结点的关键字值等于查找的关键字，成功。
- 否则，若小于根结点的关键字值，递归查左子树。
- 若大于根结点的关键字值，递归查右子树。
- 若子树为空，查找不成功。

## 什么是 AVL 树

AVL 树是一种改进版的二叉搜索树，其引入平衡因子（左子支高度与右子支高度之差的绝对值），通过旋转使其尽量保持平衡。

任何一个节点的左子支高度与右子支高度之差的绝对值不超过 1。

## 什么是红黑树

红黑树本身是由 2-3 树（最简单的 B-树）发展而来，红黑树是保持黑平衡的二叉树。

其查找会比AVL树慢一点，添加和删除元素会比 AVL 树快一点。增删改查统计性能上讲，红黑树更优。

红黑树主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。

红黑树和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。

红黑树保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 `O(logn)`。

红黑树通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。

## 什么是哈夫曼树

给定 n 个权值作为 n 个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。

构造方法：假设有 n 个权值，则构造出的哈夫曼树有 n 个叶子结点。 n 个权值分别设为 $w_1, w_2, ..., w_n$，则哈夫曼树的构造规则为：

1. 将 $w_1, w_2, ..., w_n$ 看成是有 n 棵树的森林（每棵树仅有一个结点）。
2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和。
3. 从森林中删除选取的两棵树，并将新树加入森林。
4. 重复 2、3 步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

## 常见的排序算法对比

插入排序：每一趟将一个待排序的元素， 按其关键字值的大小插入到已经排序的有序区中的适当位置上，直到全部插入完成。

| 名称     | 时间复杂度   | 空间复杂度 | 稳定性  | 基本思想                                                     |
| -------- | ------------ | ---------- | ------- | ------------------------------------------------------------ |
| 直接插入 | $O(n^2)$     | $O(1)$     | 稳定    | 每一趟将一个待排序记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。 |
| 折半插入 | $O(nlogn)$   | $O(1)$     | 稳定    | 相比直接插入排序，折半插入排序仅减少了关键字间的比较次数，而元素的移动次数不变。 |
| 希尔排序 | $O(n^{1.3})$ | $O(1)$     | 不 稳定 | 把记录按下标的一定增量分组，对每组进行直接插入排序，每次排序后减小增量，当增量减至 1 时排序完毕。 |
| 归并排序 | $O(nlogn)$   | $O(n)$     | 稳定    | 将待排序序列分成两部分，然后对两部分分别递归排序，最后进行合并。 |

交换排序：两两比较待排序元素的关键字，发现两个元素的次序相反时即进行交换，直到没有反序的元素为止。

| 名称     | 时间复杂度 | 空间复杂度 | 稳定性  | 基本思想                                                     |
| -------- | ---------- | ---------- | ------- | ------------------------------------------------------------ |
| 冒泡排序 | $O(n^2)$   | $O(1)$     | 稳定    | 比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作。 |
| 快速排序 | $O(nlogn)$ | $O(logn)$  | 不 稳定 | 在待排序的 n 个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终的位置上（归为一个元素），数据序列被此元素划分成两部分：所有关键字比该元素关键字小的元素放置在前一部分，所有比他大的元素放置在后一部分，这个过程称为一趟快速排序，以后对所有的两部分分别重复上述过程， 直至每部分内只有一个元素或空为止。 |

选择排序：每一趟从待排序的元素序列中选出关键字最大（或最小）的元素，按顺序放在已排序的元素序列的最后面（ 或最前面），直到全部排完为止。

| 名称     | 时间复杂度  | 空间复杂度 | 稳定性  | 基本思想                                                     |
| -------- | ----------- | ---------- | ------- | ------------------------------------------------------------ |
| 简单选择 | $O(n^2)$    | $O(1)$     | 不稳定  | 每次在未排序序列中找到最小元素，和未排序序列的第一个元素交换位置，再在剩余未排序序列中重复该操作直到所有元素排序完毕。 |
| 堆排序   | $O(nlog2n)$ | $O(1)$     | 不 稳定 | 一种树形选择排序。在排序过程中，将 $R[1...n]$ 看成是完全二叉树的顺序存储结构，利用完全二叉树中的双亲和孩子结点之间的关系来找到当前序列中关键最大/小的元素。 |

## 时间复杂度 O(nlogn) 的排序

快速排序、堆排序和归并排序，其中以快速排序为最好。

## 排序算法最优的时间复杂度

$O(nlogn)$

## 什么是稳定排序

若排序前后两个相等的数相对位置不变，则算法稳定。

## 常见的稳定排序算法

插入排序、冒泡排序、归并排序。

## 什么是哈希冲突，如何解决

哈希表、散列表，是根据 "键" 直接进行访问的数据结构。

也就是说，它通过把 "值" 映射到表中一个位置来访问记录，以加快查找的速度。

这个映射函数叫做散列函数，存放记录的数组叫做散列表。

常用散列函数：

1. 直接寻址法

2. 数字分析法

3. 平方取中法

4. 折叠法

5. 随机数法

处理冲突的方法：

1. 开放寻址法：当发生哈希冲突时，如果哈希表未被装满，那么可以把这个值存放到冲突位置中的下一个
   空位置中去。
2. 再散列法
3. 链地址法：对相同的哈希地址，设置一个单链表，单链表内放的都是哈希冲突元素。

散列表的评价指标——装填因子定义为：$\alpha = \dfrac{填入表中的元素个数}{散列表的长度}$。

由于表长是定值，所以，$\alpha$ 越大，填入表中的元素较多，产生冲突的可能性就越大。

## 图的深度优先遍历

将图中每个顶点的访问标志设为 FALSE, 之后搜索图中每个顶点，如果未被访问，则以该顶点 V0 为起始点出发，访问此顶点，然后依次从 V0 的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 V0 有路径相通的顶点都被访问到。

## 图的广度优先遍历

从图中的某个顶点 V0 出发，并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V0 有路径相通的顶点都被访问到。

## 单源最短路径算法

迪杰斯克拉算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。

主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。注意，该算法要求图中不存在负权边。

算法步骤如下：

1. 初始时令 $S={V_0}$，$T=\{其余顶点\}$，T 中顶点对应的距离值若存在 $<V_0, V_i>$，则 $d(V_0, V_i)$ 为 $<V_0, V_i>$ 弧上的权值，若不存在 $<V_0, V_i>$，则 $d(V_0, V_i)$ 为 $\infin$。

2. 从 T 中选取一个其距离值为最小的顶点 W 且不在 S 中，加入 S。

3. 对 T 中顶点的距离值进行修改：若加入 W 作为中间顶点，从 $V_0$ 到 $V_i$ 的距离值比不加 W 的路径要短，则修改此距离值。
4. 重复上述步骤 2 和 3，直到 S 中包含所有顶点，即 S = T 为止。

## 图的存储方式

- 邻接矩阵：用两个数组分别存储顶点和边的信息。邻接矩阵表示是唯一的，且无向图的邻接矩阵一定是一个对称矩阵。

- 邻接表：图的链式存储结构。
  - 十字链表：有向图的另一种链式存储结构。

  - 邻接多重表：无向图的链式存储结构。

## 什么是连通图

在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点 $v_i$ 到顶点 $v_j$ 有路径相连，则称 $v_i$ 和 $v_j$ 是连通的。

如果 G 是有向图，那么连接 $v_i$ 和 $v_j$ 的路径中所有的边都必须同向。

如果图中任意两点都是连通的，那么图被称作连通图。图的连通性是图的基本性质。

## 什么是最小生成树

极小连通子图，含有图中全部 n 个顶点，但只有足以构成一棵树的 n - 1 条边。如果在一棵生成树上添加一条边，必定构成一个环。

## 最小生成树算法

**普里姆算法**

取图中任意一个顶点 v 作为生成树的根，之后往生成树上添加新的顶点 w。在添加的顶点 w 和已经在生成树上的顶点 v 之间必定存在一条边，并且该边的权值在所有连通顶点 v 和 w 之间的边中取值最小。之后继续往生成树上添加顶点，直至生成树上含有 n - 1 个顶点为止。

**克鲁斯卡尔算法**

先构造一个只含 n 个顶点的子图 SG，然后从权值最小的边开始，若它的添加不使 SG 中产生回路，则在 SG 上加上这条边，如此重复，直至加上 n - 1 条边为止。