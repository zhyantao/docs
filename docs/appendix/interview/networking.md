# 计算机网络

## 主要研究问题

我们按照事先约定好的规则（协议）完成网络通信。 

- 如何定位主机
- 如何建立传输路径
- 如何解析数据

因此，考虑网络相关的问题，要时刻反问自己这 3 个问题。

## OSI 七层模型

| OSI 七层模型 | 功能                             | 传输单位     | TCP/IP 四层模型 | 协议          |
| ------------ | -------------------------------- | ------------ | --------------- | ------------- |
| 应用层       | 展示数据给用户                   |              |                 |               |
| 表示层       | 将数据表示成编程语言能管理的格式 |              |                 |               |
| 会话层       | 维持一个连接                     |              | 应用层          | DNS、HTTP     |
| 传输层       | 建立逻辑连接（协议 + 端口）  | 数据段       | 传输层          | TCP、UDP      |
| 网络层       | 路由到合适的主机                 | 数据报       | 网络层          | IP            |
| 数据链路层   | 建立物理连接（MAC 地址）    | 帧           | 数据链路层      | Ethernet、PPP |
| 物理层       | 进行数据传输                     | 位（比特流） |                 |               |

从需求出发，从协议的字面意思，我们应该也能推断出它工作在哪一层：以 TCP 和 IP 协议为例，TCP 是传输控制协议，位于传输层，而 IP 是网际互连协议，位于网络层。因此，不建议对每种协议都把它们记住，当我们有需求时，能够在网络上找到合适的协议，然后据此来编程就可以了。

在某些场景下，我们有某个需求，在需求的驱动下会讨论如何解决文章开头遇到的问题。比如，如果我们想要用浏览器安全地浏览文本，那么就需要根据 HTTPS 协议来定义、传输我们的数据。因此，在整个网络过程中，我们时刻要考虑的是现在正在使用什么协议。这种面向协议的思考过程会很合适。比如，输入地址到最后获取到页面的全过程：DNS > TCP > IP > HTTP。

其中 DNS 和 HTTP 都属于应用层的协议，TCP 是传输层协议，IP 是网络层协议。但是，我们没有提到的是数据链路层的协议。

## TCP 与 UDP 的区别

- TCP 是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达。UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性。
- TCP 通信类似打电话，接通了，确认身份后，才开始进行通行。UDP 通信类似于学校广播，靠着广播播报直接进行通信。
- TCP 只支持点对点通信。UDP 支持一对一、一对多、多对一、多对多。
- TCP 是面向字节流的，UDP 是面向报文的。 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP 一个报文只能一次发完。
- TCP 首部开销（20 字节）比 UDP 首部开销（8 字节）要大
- UDP 的主机不需要维持复杂的连接状态表。

## TCP 和 UDP 的应用场景

对某些实时性要求比较高的情况使用 UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍。

其它大部分情况下，HTTP 都是用 TCP，因为要求传输的内容可靠，不出现丢失的情况。

## 什么是 ARP 协议

ARP 协议完成了 IP 地址与物理地址的映射。

每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。

当源主机要发送数据包到目的主机时，会先检查自己的 ARP 高速缓存中有没有目的主机的 MAC 地址，如果有，就直接将数据包发到这
个 MAC 地址，如果没有，就向所在的局域网发起一个 ARP 请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个 ARP 响应数据包。

源主机收到响应数据包之后，先添加目的主机的 IP 地址与 MAC 地址的映射，再进行数据传送。

如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。

## NAT 网络地址转换

用于解决内网中的主机要和因特网上的主机通信。

由 NAT 路由器将主机的本地 IP 地址转换为全球 IP 地址，分为静态转换（转换得到的全球 IP 地址固定不变）和动态 NAT 转换。

## 从输入网址到获得页面的过程

- 浏览器查询 DNS，获取域名对应的 IP 地址：
  - 具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 host 文件和向本地 DNS 服务器进行查询等。
  - 对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析（此解析具有权威性）。如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。
  - 如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询。

- 浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立连接，发起三次握手。

- TCP/IP 连接建立起来后，浏览器向服务器发送 HTTP 请求。

- 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。

- 浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。

- 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

## 简述 TCP 3 次握手

1. 客户端发送 SYN 和 seq
2. 服务端返回 SYN 和 ACK = seq + 1
3. 客户端返回 ACK = ACK + 1

## 简述 TCP 4 次挥手

1. 客户端发送 FIN 和 seq1
2. 服务端返回 ACK = seq1 + 1
3. 服务端返回 FIN 和 seq2
4. 客户端返回 ACK = seq2 + 1

## 为什么不能 2 次握手

TCP 进行可靠传输的关键就在于维护一个序列号，三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值。如果只是两次握手，至多只有客户端的起始序列号能被确认，服务器端的序列号则得不到确认。

## 为什么需要 4 次挥手

主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即 close。

所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。

## 客户端 TIME_WAIT 的意义

第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文。

如果服务端没有收到 ACK，就会重发 FIN，如果客户端在 2MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止服务端没有收到 ACK 而不断重发 FIN。

MSL（Maximum Segment Lifetime）指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么客户端推断 ACK 已经被成功接收，则结束 TCP 连接。设置 2MSL 可以保证上一次连接的报文已经在网络中消失，不会出现与新 TCP 连接报文冲突的情况。

## 什么是 Socket

网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket。

Socket 通常用来实现客户方和服务方的连接。

Socket 是 TCP/IP 协议的一个十分流行的编程界面，一个 Socket 由一个 IP 地址和一个端口号唯一确定。但是，Socket 所支持的协议种类也不光 TCP/IP、UDP，因此两者之间是没有必然联系的。在 Java 环境下，Socket 编程主要是指基于TCP/IP 协议的网络编程。

Socket 连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的。

Socket 偏向于底层。一般很少直接使用 Socket 来编程，框架底层使用 Socket 比较多。

## Socket 的通信过程

**基于 TCP**

服务器端先初始化 Socket，然后与端口绑定，对端口进行监听，调用 accept 阻塞等待客户端连接。在这时如果有个客户端初始化一个 Socket，然后连接服务器，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

**基于 UDP**

UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。客户端只需要发送，服务端能不能接收到不用管。

## TCP 的有效传输及拥塞控制

拥塞是指一个或者多个交换点的数据报超载，TCP 又会有重传机制，导致过载。

为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量：

- 当 cwnd < ssthresh 时，使用慢开始算法。
- 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
- 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。

慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd 指数增加。

拥塞避免：cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1。

快恢复：发送方判断网络出现拥塞，就把 ssthresh 设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。

## 简述快重传

如果在超时重传定时器溢出之前，接收到连续的三个重复冗余 ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。

## 简述半连接队列

TCP 握手中，当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

优化方式：

1. 缩短 SYN timeout 时间

2. 记录 IP，若连续受到某个 IP 的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。

## 简述 SYN 攻击

SYN 攻击即利用 TCP 协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费 CPU 和内存资源。

## IP 地址有哪些分类

- A 类地址 `0[Network7][Host24]`
- B 类地址 `10[Network14][Host16]`
- C 类地址 `110[Network21][Host8]`
- D 类地址 `1110[Multicast address28]`
- E 类地址 `11110[Reserved for future use27]`

IP 地址全 0 表示本网络或本主机，全 1 表示广播地址。

## IPv4 和 IPv6区别

1. IPv6 具有更大的地址空间。
2. IPv6 使用更小的路由表。
3. IPv6 增加了增强的组播（Multicast）支持以及对流的支持（Flow Control）。
4. IPv6 加入了对自动配置（Auto Configuration）的支持。
5. IPv6具有更高的安全性。

## IPv4 和 IPv6 怎么相互通信?

可以采用双协议栈和隧道技术

双协议栈：在完全过渡到 IPv6 之前，使一部分主机（或路由器）装有两个协议栈。即一个 IPv4 和一个IPv6， 通过双协议栈进行转换。

隧道技术：是将整个 IPv6 数据报封装到 IPv4 数据报的数据部分，这样，使得 IPv6 数据报可以在 IPv4 网络的隧道中传输。

## IPv4 的替代方案

IPv4 的替代方案是 IPv6，IPv6 共 128 位。

相对 IPv4 的主要改进

1. 地址变长了，从 32 位变成了 128 位
2. 简化了 IP 分组的基本首部，包含 8 个段（IPv4 包含 12 个段），这一改变使得路由器可以尽快地处理分组，从而可以改善吞吐率。
3. IPv6 更好地支持选项，这一特征加快了分组处理速度。

## 什么是 SQL 注入

SQL 注入就是通过把 SQL 命令插入到 Web 表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。

## 谈一谈 XSS 攻击

XSS 是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到 Web 页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

## 对称加密与非对称加密的区别

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。

非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢。

## 说一个网络加密算法并解释一下

DES 使用一个 56 位的密钥以及附加的 8 位奇偶校验位，产生最大 64 位的分组大小。这是一个迭代的分组密码，使用称为 Feistel 的技术，其中将加密的文本块分成两半。使用子密钥对其中一半应用循环功能，然后将输出与另一半进行&quot;异或&quot;运算；接着交换这两半，这一过程会继续下去，但最后一个循环不交换。DES 使用 16 个循环

## ISA 的加密和解密钥匙一样吗

不一样

## RSA 和 DES 在网络数据加密中的应用

RSA 主要在密钥分发，DES 主要在加密传输

RSA 的安全性依赖于大数分解。公钥和私钥都是两个大素数（ 大于 100 个十进制位）的函数。

## TCP 黏包是怎么产生的

TCP 是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个 TCP 报文中发出去的可能性。

可以简单的理解成客户端调用了两次 send，服务器端一个 recv 就把信息都读出来了。

## 怎么解决拆包和粘包

固定发送信息长度，或在两个信息之间加入分隔符。

## 谈谈你对 ARQ 协议的理解

**自动重传请求 ARQ 协议**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。 

**连续 ARQ 协议**

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

## 简述滑动窗口

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。

## 简述流量控制

流量控制：实质就是限制发送方的数据流量，使其发送的速率不要超过接收方处理的速率。

## 简述停止等待协议

- 只有收到序号正确的确认帧 ACKn 后，才更新发送状态变量 V(S)一次，并发送新的数据帧。接收端接收到数据帧时，就要将发送序号 N(S) 与本地的接收状态变量 V(R) 相比较。
- 若二者相等就表明是新的数据帧，就收下，并发送确认。
- 否则为重复帧，就必须丢弃。但这时仍须向发送端发送确认帧 ACKn，而接收状态变量 V(R) 和确认序号 n 都不变。
- 连续出现相同发送序号的数据帧，表明发送端进行了超时重传。连续出现相同序号的确认帧，表明接收端收到了重复帧。
- 发送端在发送完数据帧时，必须在其发送缓存中暂时保留这个数据帧的副本。这样才能在出差错时进行重传。只有确认对方已经收到这个数据帧时，才可以清除这个副本。

## forward 和 redirect 的区别

转发是服务器行为。服务器直接向目标地址访问 URL，将相应内容读取之后发给浏览器，用户浏览器地址栏 URL 不变，转发页面和转发到的页面可以共享 request 里面的数据。

重定向是利用服务器返回的状态码来实现的，如果服务器返回 301 或者 302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏 URL 会发生改变，而且不能共享数据。

## 什么是 HTTP 协议

HTTP 协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为 "超文本传输协议"。

## 一个完整的 HTTP 请求过程

1. 建立 TCP 连接
2. 浏览器向服务器发送请求行：`GET /sample/hello.jsp HTTP/1.1`
3. 浏览器发送请求头：浏览器发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息，**之后浏览器发送一空白行来通知服务器**，它已经结束了该头信息的发送。
4. 服务器应答：`HTTP/1.1 200 OK` 应答的第一部分是协议的版本号和应答状态码。
5. 服务器发送应答头
6. 服务器返回实际数据
7. 服务器关闭 TCP 连接

## HTTP 1.0、1.1、2.0 的区别

**HTTP 1.0**

无状态、无连接

**HTTP 1.1**

默认持久连接、管线化、断点续传

**HTTP 2.0**

二进制分帧、首部压缩、流量控制、多路复用、请求优先级、服务器推送

## HTTP 请求方式

| 请求方式 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| GET      | 用于请求访问已经被 URI（统一资源标识符）识别的资源，可以通过 URL 传参给服务器 |
| POST     | 用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐使用 POST 方式 |
| PUT      | 传输文件，报文主体中包含文件内容，保存到对应 URI 位置。      |
| HEAD     | 获得报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URI 是否有效 |
| PATCH    | 客户端向服务器传送的数据取代指定的文档的内容（部分取代）     |
| TRACE    | 回显客户端请求服务器的原始请求报文，用于 "回环" 诊断         |
| DELETE   | 删除文件，与 PUT 方法相反，删除对应 URI 位置的文件           |
| OPTIONS  | 查询相应 URI 支持的 HTTP 方法                                |

## POST和GET有哪些区别

1. GET 重点在从服务器上获取资源，POST 重点在向服务器发送数据。

2. GET 传输的数据量小，因为受 URL 长度限制，但效率较高，POST 可以传输大量数据，所以上传文件时只能用 POST 方式。

3. GET 是不安全的，因为 GET 请求发送数据是在 URL 上可见的，可能会泄露私密信息，POST 放在请求头部，是安全的。

## HTTP 状态码分类

| 类别 | 描述                                    |
| ---- | --------------------------------------- |
| 1XX  | 指示信息–表示请求已接收，正在处理       |
| 2XX  | 成功–表示请求已被成功接收、理解、接受   |
| 3XX  | 重定向–要完成请求必须进行更进一步的操作 |
| 4XX  | 客户端错误–请求有语法错误或请求无法实现 |
| 5XX  | 服务器端错误–服务器未能实现合法的请求   |

## 常用的 HTTP 状态码

200 请求成功。

301 永久性重定向，302 临时重定向。

400 请求报文有错误，403 请求的资源禁止访问，404 请求的资源不存在。

500 服务器内部错误。

## HTTPS 协议的工作过程

1. 首先 HTTP 请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA 加密）等进行校验。
2. 客户端如果校验通过后，就根据证书的公钥的有效性，生成随机数，随机数使用公钥进行加密（RSA 加密）。
3. 消息体产生的后，对它的摘要进行 MD5（或者 SHA1）算法加密，此时就得到了 RSA 签名。
4. 发送给服务端，此时只有服务端（RSA 私钥）能解密。
5. 解密得到的随机数，再用 AES 加密，作为密钥（此时的密钥只有客户端和服务端知道）。

HTTPS 是以安全为目标的 HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。

HTTPS 实际上应用了 Netscape 的安全套接字层（SSL）作为 HTTP 应用层的子层。（HTTPS 使用端口 443，而不是像 HTTP 那样使用端口 80 来和 TCP/IP 进行通信。）

## SSL 协议是什么

SSL（Secure Socket Layer）是 Netscape 研发的用以保障在 Internet 上数据传输的安全，使用了数据加密（Encryption）技术。

## HTTP 和 HTTPS 的区别

1. HTTPS 需要拿到 CA 证书，需要钱的。
2. 端口不一样，HTTP 是 80，HTTPS 是 443。
3. HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。
4. HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

## HTTP header 的内容

**常规**

```text
请求网址: https://stats.segmentfault.net/js/plausible.js
请求方法: GET
状态代码: 200 
远程地址: 124.70.100.145:443
引荐来源网址政策: strict-origin-when-cross-origin
```

**响应标头**

```text
access-control-allow-origin: *
cache-control: max-age=0, private, must-revalidate
content-encoding: gzip
content-type: application/javascript
cross-origin-resource-policy: cross-origin
date: Sat, 21 May 2022 13:29:04 GMT
server: Cowboy
vary: Accept-Encoding
x-content-type-options: nosniff
```

**请求标头**

```text
:authority: stats.segmentfault.net
:method: GET
:path: /js/plausible.js
:scheme: https
accept: */*
accept-encoding: gzip, deflate, br
accept-language: zh-CN,zh;q=0.9,en;q=0.8
referer: https://segmentfault.com/
```

## 什么是数字签名

为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。

## 什么是数字证书

对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。

## Cookie 和 Session 的区别

**Cookie**

Cookie 是由服务器端生成，发送给 User-Agent（一般是浏览器），浏览器将 Cookie 的 key/value 保存到某个目录下的文本文件内，下次请求同一网站时就发送该 Cookie 给服务器（前提是浏览器设置为启用 Cookie）。

Cookie 名称和值可以由服务器端开发自己定义，对于 JSP 而言也可以直接写入 jsessionid，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。

Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，另一个重要应用场合是&quot;购物车&quot;之类处理。

Cookie 不安全。

**Session**

Session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 Session。

服务器默认为客户浏览器的 Cookie 中设置 sessionid，这个 sessionid 就和 Cookie 对应，浏览器在向服务器请求过程中传输的 Cookie 包含 sessionid，服务器根据传输 Cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。

**区别**

1. Cookie 数据存放在客户端上，安全性较差，Session 数据放在服务器上，安全性相对更高。

2. 单个 Cookie 保存的数据不能超过 4K，Session 无此限制。

3. Session 一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用 Cookie。

## CSMA/CD 的原理

CSMA/CD（Carrier Sense Multiple Access/Collision Detect）即载波监听多路访问/冲突检测方法。

原理：先听后发，边发边听，冲突停发，随机延迟后重发。

## ICMP 协议

ICMP（Internet Control Message Protocol）互联网控制报文协议。用于在 IP 主机、路由器之间传递控制消息。

控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。

ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。

"Ping" 的过程实际上就是 ICMP 协议工作的过程。还有其他的网络命令如跟踪路由的 Tracert 命令也是基于 ICMP 协议的。

## 保护频带

在给定信道的上下限处留出的未占用窄频带。其目的是确保信道间有足够隔离，防止相邻信道干扰。

## 二层交换机是哪一层的设备，与三层交换机之间的区别？

二层交换机属数据链路层设备，可以识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。

三层交换机就是具有部分路由器功能的交换机

三层交换技术 = 二层交换技术＋ 三层转发技术。

## 单工、半双工、全双工

- 单工：单向通信，只能有一个方向的通信，而没有反方向的交互。

- 半双工：双向交替通信，通信的双方都可以发送信息，但不能同时发送，也不能同时接收。

- 全双工：双向同时通信，通信的双方可以同时发送和接收信息。半双工和全双工通信都需要两条信道。


## 100 Base-T 是什么

100 表示介质传送速度是 100 bps。Base 表示基带传送，传送数字信号，与宽带传送相对应，T 表示介质是双绞线

