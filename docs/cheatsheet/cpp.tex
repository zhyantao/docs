\documentclass[a4paper]{ctexart}
\usepackage[landscape, margin=1in]{geometry} % 调整页边距
\usepackage{multicol}
\usepackage{tikz}
\usetikzlibrary{shapes.multipart}
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
}

\begin{document}

\begin{multicols}{2}[\section*{C++ 小抄表}] % 使用两列并添加标题

  \tikzstyle{mybox} = [
  draw=black, fill=white, very thick,
  rectangle split, rectangle split parts=2,
  rectangle split part align={center, center},
  inner sep=10pt, inner ysep=10pt,
  rounded corners,
  text width=0.95\columnwidth, % 调整宽度适应列宽
  ]

  \tikzstyle{fancytitle} = [
  fill=gray!20, text=white, font=\bfseries,
  rectangle, rounded corners,
  draw=black, inner sep=1pt, inner ysep=2pt
  ]

  % 基本框架
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{one} 基本框架
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef long double ld;

const ll mod7 = 1e9 + 7;
const ll mod9 = 998244353;
const ll INF = 2 * 1024 * 1024 * 1023;
const char nl = '\n';

int main() {
    cin.tie(nullptr)->sync_with_stdio(false);

    int t;
    cin >> t;

    auto solve = [&]() {
        // TODO
        cout << nl; // 使用 endl 会导致 tie 失效
    };

    while (t--) {
        solve();
    }
    return 0;
}
        \end{lstlisting}
    };
  \end{tikzpicture}

  % 类型转换
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
string str = "";
char *ptr = nullptr;
char chs[100] = { 0 };
ptr = const_cast< char * >(str.c_str()); // string -> char*
double d = atof("0.23");                 // string -> double
int i = atoi("1021");                    // string -> int
long l = atol("303992");                 // string -> long
sprintf(chs, "%f", 2.3);                 // double -> char[]
strcpy(chs, ptr);                        // char* -> char[]
string str(chs);                         // char[] -> string
        \end{lstlisting}
      \nodepart{one} 类型转换
    };
  \end{tikzpicture}

  % 数组
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{one} 数组
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
char arr[] = "hello";
arr[0] = 'X';              // 正确，修改数组元素
const char *ptr = "world"; // 应使用 const，因为字符串字面值不可改
        \end{lstlisting}
    };
  \end{tikzpicture}

  % 动态数组 \verb!vector!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{one} 动态数组 \verb!vector!
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
vector< int > arr(sz, val);                      // sz 和 val 可选
vector< vector< int > > dp(m, vector< int >(n)); // m * n 的数组
arr.empty(), arr.size() arr.push_back(val), arr.pop_back(), arr[i] = val
        \end{lstlisting}
    };
  \end{tikzpicture}

  % 字符串 \verb!string!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{one} 字符串 \verb!string!
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
string str = "ABCDEFG";
str.size(), str.empty()
str.push_back('X'), str.pop_back(), str[i] = 'X'
str == s2, str.substr(start, len)
        \end{lstlisting}
    };
  \end{tikzpicture}

  % 哈希表 \verb!unordered_map!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
unordered_map<string, int> map;
map.size(), map.empty(), map.count(key)
map.insert({key, val}), map.erase(key), map[key] = val
        \end{lstlisting}
      \nodepart{one} 哈希表 \verb!unordered_map!
    };
  \end{tikzpicture}

  % 哈希集合 \verb!unordered_set!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
unordered_set<string> set;
set.size(), set.empty(), set.count(key)
set.insert(key), set.erase(key)
        \end{lstlisting}
      \nodepart{one} 哈希集合 \verb!unordered_set!
    };
  \end{tikzpicture}

  % 队列 \verb!queue!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
queue<string> q;
q.size(), q.empty(), q.push(val), q.pop(), q.front()
        \end{lstlisting}
      \nodepart{one} 队列 \verb!queue!
    };
  \end{tikzpicture}

  % 堆栈 \verb!stack!
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
stack<string> s;
s.size(), s.empty(), s.push(val), s.pop(), s.top()
        \end{lstlisting}
      \nodepart{one} 堆栈 \verb!stack!
    };
  \end{tikzpicture}

  % 运算符重载
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      作为类成员时，重载二元运算符参数为另一个对象，一元运算符不需额外参数。
      作为全局函数时，重载二元运算符需要两个参数，一元运算符需要一个参数。
      示例：
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
// 作为成员函数
Complex Complex::operator+(const Complex &a) const {
  return Complex(real + a.real, img + a.img);
}
// 作为全局函数
Complex operator+(const Complex &a, int b) {
  return Complex(a.real + b, a.img);
}
// 类中声明全局函数为友元
friend Complex operator+<>(...);
        \end{lstlisting}
      \nodepart{one} 运算符重载
    };
  \end{tikzpicture}

  % 工具函数
  \begin{tikzpicture}
    \node [mybox] (box){
      \nodepart{two}
      \begin{lstlisting}[language=C++, basicstyle=\ttfamily\footnotesize]
sort(v1.begin(), v1.end(), greater<int>());
sort(v1.begin(), v1.end(), [](int a, int b) { return a > b; });
reverse(v1.begin(), v1.end());
binary_search(v1.begin(), v1.end(), target);
        \end{lstlisting}
      \nodepart{one} 工具函数
    };
  \end{tikzpicture}

\end{multicols}

\end{document}