\documentclass[a4paper]{ctexart}
\usepackage[landscape]{geometry}
\usepackage{multicol}
\usepackage{tikz}
\usepackage{listings}

\makeatletter

\advance\topmargin-.8in
\advance\textheight3in
\advance\textwidth3in
\advance\oddsidemargin-1.5in
\advance\evensidemargin-1.5in
\parindent0pt
\parskip2pt

\begin{document}

\begin{multicols*}{3}

  \tikzstyle{mybox} = [draw=black, fill=white, very thick,
  rectangle, rounded corners, inner sep=10pt, inner ysep=10pt]
  \tikzstyle{fancytitle} =[fill={rgb:red,220;green,220;blue,221},
  text=white, font=\bfseries]
  %------------ START OF CONTENT -------------


  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        Java 引用传递 \verb|ArrayList<Integer> b = a| 可以修改自定义类型的值。
        Java 无地址传递，在递归遍历树的同时想修改变量，\textbf{声明为全局变量}可降低难度。

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {指针和引用};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        初始化：
        \verb!int[] v = new int[];!\\
        \verb!boolean[][] vv = new boolean[m][n];!\\
        判空：
        \verb!v == null || v.length == 0 // 一维!\\
        \verb!vv == null || vv.length == null || ! \\
        \verb!              vv[0].length == 0 // 二维!\\
        截取：
        \verb!subarr = Arrays.copyOfRange(arr,2,6);!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {数组 int [ ]};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        初始化：
        \verb!String str = "hello world";!\\
        \verb!StringBuilder sb = new StringBuilder(str);!\\
        类型转换：\verb!sb.toString();!\\
        增：
        \verb!sb.append(true);  sb.insert(i, "abc");!\\
        删：
        \verb!sb.deleteCharAt(i);    sb.delete(i,j);!\\
        改：
        \verb!sb.setCharAt(i,'z');!\\
        查：
        \verb!char c = str.charAt(i);!\\
        判等：
        \verb!s1.equals(s2);!
        判空：
        \verb!s1.isEmpty();!\\
        截取：
        \verb!str.substring(i); str.substring(i,j);!\\
        拼接：
        \verb!str.concat("abc");!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {字符串 String};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \verb!ArrayList<Integer> v = new ArrayList<>();!\\
        \verb!isEmpty(), size()!\\
        \verb!add(), remove(), get(), set(1, 100)!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {动态数组};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \verb!LinkedList<Integer> v = new LinkedList<>();!\\
        \verb!isEmpty(), size(), contains()!\\
        \verb!add(), remove(), get() // 默认尾插，头删!\\
        \verb!addFirst(), removeFirst(), removeLast()!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {双向链表};
  \end{tikzpicture}

  \hfill



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \verb!Map<Integer, String> map = new HashMap<>();!\\
        \verb!containsKey(), keySet(), getOrDefault()!\\
        \verb!put(), remove(), get()!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {哈希表（哈希集合类似）};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \verb!Map<String> map = new TreeSet<>();!\\
        \verb!put(), remove(), containsKey(), firstKey()!\\
        \verb!lastKey(), floorKey(), ceilingKey()!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {有序表（有序集合类似）};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \verb!Deque<String> stack = new ArrayDeque<>();!\\
        \verb!Deque<String> queue = new LinkedDeque<>();!\\
        \verb!isEmpty(), size()!\\
        \verb!addFirst(), removeFirst(), peekFirst()!\\
        \verb!addLast(), removeLast(), peekLast()!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {双端队列（代替栈和队列）};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
Integer.parseInt(s) // String -> int
String.valueOf(chs) // int, char[] -> String
'8' - '0'           // char -> int
Double.valueOf(i)   // int -> double
foo.intValue()      // double -> int
list = Arrays.asList(arr) // [] -> ArrayList 
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {类型转换};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
TreeNode p = new TreeNode(-1, head);
TreeNode dummy = p; // 保存头结点位置，不移动
return dummy.next;
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {哨兵：哑元结点（提高效率）};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
Arrays.sort(nums);       // 数组排序
Arrays.binarySearch(nums, 23);
Arrays.stream(nums).max().getAsInt();
Collections.sort(list); // 列表排序
list.sort(Collections.reverseOrder());// 逆序
Collections.reverse(list); // 翻转链表
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {Arrays 和 Collections 工具包};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        默认 int 无符号最大值约为 $40 \times 10^8$（32 位）。\\
        \verb!BigInteger A = BigInteger.valueOf(23);!\\
        \verb!BigDecimal B = BigDecimal.valueOf(1234.56);!\\
        \verb!A.add(A), A.subtract(A), !\\
        \verb!A.multiply(A), A.divide(A)!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {大数计算：java.math.*};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        基于数组实现：\verb!key! 为数组下标，\verb!value! 为元素值。\\
        \verb!int[] map = new int[256]; // ASCII -> 下标!

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {简易哈希表的实现};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
ArrayList<String> list = new ArrayList<>();
Set<String> set = new HashSet<>();
set.addAll(list);
ArrayList<String> ret = new ArrayList<>(set);
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {ArrayList 元素去重};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
while (n > 0) {
  digit = n % 10;   // 取出各位
  n = n / 10;       // 更新数字
} // 注意处理最值 Integer.MAX_VALUE
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {取出整数中的每一位};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
Map<String, String> map = new HashMap<>();
for (Map.Entry<String, String> entry : 
                          map.entrySet()) {
  int key = entry.getKey();
  int value = entry.getValue();
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {遍历哈希表或哈希集合};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
void traverse(ListNode head) {
  // 前序遍历代码
  traverse(head.next);
  // 后序遍历代码
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {链表的遍历};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
void traverse(TreeNode root) {
  if (root == null) return;
  // 前序遍历代码
  traverse(root.left);
  // 中序遍历代码
  traverse(root.right);
  // 后序遍历代码
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {二叉树的遍历};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
class TreeNode {
  int val;
  TreeNode[] children;
}
void traverse(TreeNode root) {
  for (TreeNode child : children)
    traverse(child);
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {图（N 叉树）的遍历};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 利用这个例子学习如何使用递归的返回值
int traverse(TreeNode root) {
  // 叶节点相当于 dp 的最后一个状态
  if (root == null)
    return 0; // 实际意义： 0 层
  // 从叶结点到根结点逆向推理 left 和 right
  int left = traverse(root.left);
  int right = traverse(root.right);
  // 下一次递归利用上一次递归 return 的结果
  return left>right ? left+1 : right+1;
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {求二叉树的深度：递归实现};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        % 代码段要顶格写，否则，会看起来跑到 minipage 外面去了
        \begin{verbatim}
Queue<Integer> queue = new LinkedList<>();
void traverse(TreeNode root) {
  if (root != null)
    queue.offer(root);
  else
    return;

  TreeNode p = queue.poll();
  while (p != null) {
    if (p.left != null)
      queue.offer(p.left);
    if (p.right != null)
      queue.offer(p.right);
    if ( ! queue.isEmpty())
      p = queue.poll();
  }
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {二叉树的层序遍历};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 类名必须为 Main，不含 package xxx 信息
public class Main {
  public static void main(String[] args) {
    Scanner in = new Scanner(System.in);
    // 若有下一个字符 hasNext 返回真
    // 若碰到行尾符号 hasNextLine 返回真
    // 注意 hasNextXXX 与 nextXXX 须同时出现
    while (in.hasNextInt()) { // 检查
      int a = in.nextInt();
      int b = in.nextInt(); // 指针向前移动
      // 四舍五入，保留两位小数
      String.format("%.2f", num);
    }
  }
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {ACM 模式：import java.util.Scanner};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 以补码形式存储，以原码形式输出到屏幕
// int 类型按道理应该写 32 位，下面写法不严谨
9     // 原码 01001 补码 01001 反码 01001
-1    // 原码 10001 补码 11111 反码 11110
~ 9   // ~ 01001 = 10110 原码 11010 = -10
a ^ a    // = 0，判断两数是否相同
a ^ 0x1  // 对 a 的第 0 位求反
a ^ b    // 求 a + b 的各位之和，无进位
a & b    // 求 a + b 各位的进位
a & 0xFE // 关闭或检查 a 的第 0 位
a | 0x01 // 开启 a 的第 0 位
n & (~ n + 1) // 获取 n 的二进制最右侧的 1
n &= (n - 1)  // 抹掉 n 的二进制最后侧的 1

int add(int a,int b) {
  int sum = a; // 求两数之和的例子
  int add = b;
  while (add != 0) {
    int tmp = sum ^ add;
    add = (sum & add) << 1;
    sum = tmp;
  }
  return sum;
}
\end{verbatim}

        若出现新的运算规则，题目实际想让自己定义运算。

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {位运算};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        $T(N) = a * T(\displaystyle\frac{N}{b}) + O(N^d)$

        $N$ 是问题的总规模，
        $a$ 是递归调用的次数，
        $\frac{N}{b}$ 是子问题的规模，
        $O(N^d)$ 是除递归代码外的时间复杂度。

        - $log_b a < d \Rightarrow O(N^d)$ \\
        - $log_b a > d \Rightarrow O(Nlog_b a)$ \\
        - $log_b a = d \Rightarrow O(N^d logN)$

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {计算递归的时间复杂度：master 公式};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 注意这里有多处使用 return
int binarySearch(int[] arr, int target,
                 int left, int right) {
  if (left <= right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] == target)
      return mid;
    if (arr[mid] > target) // 向左查找
      return binarySearch(arr, target,
                          left, mid - 1);
    if (arr[mid] < target) // 向右查找
      return binarySearch(arr, target,
                          mid + 1, right);
  }
  return -1; // 没找到
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {二分查找：递归实现};
  \end{tikzpicture}


  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 需要借助栈和指针来实现
void inorder(TreeNode root) {
  Stack<TreeNode> stack = new Stack<>();
  TreeNode cur = root;
  while (cur != null || !stack.isEmpty()) {
    if (cur != null) { // 遍历左子节点，入栈
      stack.push(cur);
      cur = cur.left;
    }
    else { // 遍历完左子节点，出栈，保存结果
      cur = stack.peek();
      stack.pop();
      // ans.add(cur.val);
      cur = cur.right;
    }
  }
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {中序遍历：迭代实现};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
void preorder(TreeNode root) {
  Stack<TreeNode> stack = new Stack<>();
  if (root == null)
    return;
  stack.push(root);
  while (!stack.isEmpty()) {
    TreeNode cur = stack.peek();
    stack.pop();
    // ans.add(cur.val);
    if (cur.right != null) // 先右后左
      stack.push(cur.right);
    if (cur.left != null)
      stack.push(cur.left);
  }
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {前序遍历：迭代实现};
  \end{tikzpicture}


  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
// 和前序遍历类似的代码，也需要借助栈来实现
// 遍历顺序不一样，且多了一个 reverse 环节
void postorder(TreeNode root) {
  Stack<TreeNode> stack = new Stack<>();
  TreeNode cur = root;
  if (root == null)
    return;
  stack.push(root);
  while (!stack.isEmpty()) {
    TreeNode cur = stack.peek();
    stack.pop();
    // ans.add(cur.val);
    if (cur.left != null) // 先左后右
      stack.push(cur.left);
    if (cur.right != null)
      stack.push(cur.right);
  }
  reverse(ans);
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {后序遍历：迭代实现};
  \end{tikzpicture}



  %------------- START SECTION ---------------
  \begin{tikzpicture}
    \node [mybox] (box){%
      \begin{minipage}{0.3\textwidth}

        \begin{verbatim}
reverseList(ListNode head) {
  if (head == null || head.next == null)
      return head;
  
  // 三指针翻转链表
  ListNode pre = null;
  ListNode cur = head;
  while (cur != null) {
    ListNode nxt = cur.next; // 临时保存
    cur.next = pre;
    // 更新节点
    pre = cur;
    cur = nxt;
  }
  return pre;
}
\end{verbatim}

      \end{minipage}
    };
    %-----------------------------------------
    \node[fancytitle, right=10pt] at (box.north west) {后序遍历：迭代实现};
  \end{tikzpicture}



  %------------ END OF CONTENT ---------------
\end{multicols*}

\end{document}
