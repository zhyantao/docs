# 理论基础

## 操作系统概述

操作系统是一段程序，运行于硬件之上，它是一种系统软件。
它负责协调硬件、软件等计算机资源的工作，为上层用户、应用程序提供简单易用的服务。
因此，操作系统是一个资源管理者，它管理着 CPU 、存储器、文件、设备。

操作系统具有四大特征（牢记）：

- 并发，交替上 CPU 运行
- 共享，共享方式分为两种：互斥共享（如摄像头）和同时共享（如磁盘）
- 虚拟，对 CPU 的虚拟就是线程（时分复用），对磁盘的虚拟就是文件（空分复用）
- 异步，指进程以不可预知的速度向前推进，不知道什么时候开始、暂停、结束

没有并发和共享，就谈不上虚拟和异步，因此并发和共享是操作系统的两个最基本的特征。

### 操作系统的运行机制

手工编写高级语言代码（如 C 语言）经由编译器编译后可以生成硬件理解的语言。
将硬件理解的语言（代码）放在磁盘的合适位置，磁盘开始从那个位置开始执行。

虽然同为操作系统的源代码，在同一份操作系统源代码中并不是所有语句都具备相同的权限。
能够直接和硬件打交道的代码是内核程序，它们对应的指令是特权指令；
而使用内核程序给我们开放的接口进行编写的程序是应用程序，对应的指令是非特权指令。

操作系统的层次结构如下图所示：

```{figure} ../../_static/images/os-architecture.*
操作系统的层次结构
```

正在运行特权指令的处理器处于内核态（也叫核心态或管态），正在运行非特权指令的处理器则处于用户态（也叫目态）。
从内核态到用户态的转变，需要修改一条 PSW 特权指令，而从用户态转变到内核态则由中断引起，硬件自动完成。
中断的作用是让操作系统内核强行夺回 CPU 的控制权，使 CPU 从用户态变为内核态。
因此，没有中断机制，就不可能实现操作系统，不可能实现程序并发。

中断分为两种：内中断和外中断。
内中断也叫异常，触发内中断的条件可以是陷阱（trap）、故障（fault）或终止（abort）。
外中断简称中断，触发条件是时钟中断或 I/O 中断请求。
CPU 在执行指令时会自动检查是否有异常发生，由程序自动触发内中断。
在每个指令周期的末尾，CPU 都会检查是否由外部信号需要处理，以此判断是否需要执行外中断。
内中断和外中断都会通过中断向量表来找到相应的中断处理程序。

当我们需要进行设备管理、文件管理、进程管理、进程通信、内存管理时，就需要用到系统调用了。
系统调用时操作系统对应用程序或程序员提供的接口。
系统调用的通过传参、陷入或访管指令触发，由操作系统内核程序处理系统调用请求，返回给应用程序。

宏内核性能高，但是内核代码庞大，结构混乱，难以维护。微内核功能少，但是需要频繁地变态，性能差。
**在我们后续的实验中，使用的是宏内核设计。**

## 进程管理

### 进程

进程是进程实体的运行过程，是系统资源进行分配和调度的一个独立单位。

一个进程实体/映像包括以下几个部分：

- PCB（进程控制块）
- 程序段
- 数据段

进程控制块又可以细分为：

- 进程描述信息：进程标识符 PID、用户标识符 UID
- 进程控制和管理信息：CPU、磁盘、网络流量使用情况、进程当前状态（就绪、阻塞、运行...）
- 资源分配清单：正在使用哪些文件、正在使用哪些内存区域、正在使用哪些 I/O 设备
- CPU 相关信息：如 PSW、PC 等各种寄存器的值（用于实现进程切换）

当我们 `fork` 出来一个新的进程后，它们的程序段是相同的，但是它们的 PCB 和数据段并不相同。

进程的组织方式可以分为链接和索引两种。
链接方式是指按照进程状态将 PCB 分为多个队列，操作系统持有指向各个队列的指针。
索引方式是指根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针。

进程之间的切换如下图所示：

```{figure} ../../_static/images/os-process-schedule.*
操作系统的进程调度的 5 状态模型
```

在进程控制的过程中，必须完成的三件事：

- 更新 PCB 中的相关信息：修改进程状态标志、保存运行环境、恢复运行环境
- 将 PCB 插入合适的队列
- 分配/回收资源

### 进程间的通信

进程之间的通信方式有三种：

1、共享存储

设置共享空间，然后互斥地访问共享空间。

2、管道通信

设置一个特殊的共享文件（管道），其实就是一个缓冲区。
但是一个管道只能实现半双工通信，要想实现双向同时通信要建立两个管道。
各个进程互斥地访问管道。

3、消息传递

传递结构化的消息（消息头和消息体），提供提供 "发送/接收原语"。
在具体的实现上，一种是直接通信，将消息直接挂在接收方的消息队列里，另一种是信箱方式，先把消息发送到信箱中。

### 线程

进程是资源分配的基本单位，线程是 CPU 调度的基本单位。

同一进程内的各个线程共享拥有的资源，同一进程内的线程切换不会导致进程切换。

引入进程的目的是增加并发度，减少并发带来的系统开销。

### CPU 调度

按照某种算法选择一个进程，将 CPU 分配给它。

````{margin}
```{note}
存储器的种类很多，按其用途可分为主存储器（又叫 "内存储器"，简称 "内存"）和辅助存储器（又称
"外存储器"，简称 "外存"）。外存简单来说就是日常所说的 "存储"，主要分为固态硬盘跟机械硬盘。
内存是可以进行高速读写的储存器，包括常见的内存条、显卡内存（又叫 "显存"）。
```
````

为减轻系统负担，提高系统的资源利用率，将暂时不执行的进程调到外存，变为 "挂起态"。

```{figure} ../../_static/images/os-process-schedule-7.*
操作系统的进程调度的 7 状态模型
```

CPU 的调度分为三个层次：

```{list-table}
:header-rows: 1
:widths: 15, 20, 60, 10

* - 调度层次
  - 调度方向
  - 调度规则
  - 频率
* - 高级调度 (作业调度)
  - 外存 $\rightarrow$ 内存
  - 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程
  - 低
* - 中级调度 (内存调度)
  - 外存 $\rightarrow$ 内存
  - 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
  - 中
* - 低级调度 (进程调度)
  - 内存 $\rightarrow$ CPU
  - 按照某种规则，从就绪队列中选择一个进程为其分配处理机
  - 高
```

### 资源调度

所谓调度，需要回答的核心问题是：在何时将何种任务分配给何种资源以何种方式执行。
调度广泛存在于操作系统、编程语言运行时、容器编排和业务系统中，其核心目的是
"对有限的资源进行分配以实现最大化资源的利用率、降低系统的尾延迟或最小化任务的完工时间" [^cite_ref-1]。

在计算机科学中，调度就是一种将任务（Work）分配给资源的方法。
任务可能是虚拟的计算任务，例如线程、进程或者数据流，这些任务会被调度到硬件资源上执行，例如：处理器 CPU 等设备
[^cite_ref-2]。

在 Linux 操作系统中，带执行的任务就是操作系统的基本单位是线程，而可分配的资源就是 CPU 的时间。
类似地，Kubernetes 调度的基本单位是 Pod，可分配的资源是 Node [^cite_ref-2]。

关于操作系统的调度问题及其相关的优化，作者 draveness 在 *调度系统设计精要* [^cite_ref-2]
一文中做了详细介绍。

### 调度算法的评价指标

1、CPU 利用率

$$
CPU 利用率 = \frac{忙碌的时间}{总时间}
$$

2、系统吞吐量

$$
系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}
$$

3、周转时间

$$
周转时间 &= 作业完成时间 - 作业提交时间 \\ \\
平均周转时间 &= \frac{各作业周转时间之和}{作业数} \\ \\
带权周转时间 &= \frac{作业周转时间}{作业实际运行的时间} \\ \\
平均带权周转时间 &= \frac{各作业带权周转时间之和}{作业数}
$$

4、等待时间

$$
等待时间 = 进程或作业等待被服务的时间之和
$$

5、响应时间

$$
响应时间 = 从用户提交请求到首次产生响应所用的时间
$$

### 调度算法

```{list-table}
:header-rows: 1
:widths: 35, 50, 15

* - 调度算法
  - 特点
  - 产生饥饿
* - 先来先服务（FCFS）
  - 不公平，对长作业有利，对短作业不利
  - $\times$
* - 短作业优先（SJF/SPF/SRTN）
  - 不公平，对短作业有利，对长作业不利
  - $\checkmark$
* - 高响应比优先（HRRN）
  - 综合 FCFS 和 SJF 的优点
  - $\times$
* - 时间片轮转（RR）
  - 公平，适用于分时系统
  - $\times$
* - 优先级调度（PSA）
  - 不公平，适用于实时系统
  - $\checkmark$
* - 多级反馈队列（MFQS）
  - 综合 RR 和 PSA 的优点
  - $\checkmark$
```

## 进程的同步和互斥

访问临界区需要遵循的四个原则：

- 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
- 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
- 优先等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
- 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

## 内存管理

### 内存管理的概念

### 内存空间的扩充

## 文件管理

## 输入输出（I/O）管理

ggg

---

[^cite_ref-1]: <https://hliangzhao.cn/articles/000001632804098b0d15f52e2794eba809f483763f603b1000>
[^cite_ref-2]: <https://draveness.me/system-design-scheduler>
