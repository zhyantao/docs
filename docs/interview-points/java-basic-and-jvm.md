# Java 与 JVM

## 什么是面向对象和面向过程

面向对象是将编程的粒度看作是一个个独立而又相互调用的对象。

对象之间消息的传递依靠对象提供的接口，也就是 public 方法。

面向过程是将编程的粒度看作是一个个独立而又相互调用的函数。函数之间的消息传递依靠的是函数参数以及返回值。

这两种思想的差异在于解决问题时，我们是将原问题分解为一个个步骤还是一个个对象。

## 面向对象的三大特性

面向对象的三个特性是封装、继承和多态。

封装是隐藏具体的实现细节，我们对外可以提供一个统一接口，让它完成某项功能。

继承是指在父类的基础上添加新的功能。类间的继承关系一般在编译期就确定了。

多态是指我们用父类型的引用指向了子类的对象。多态也叫后期绑定行为的一种体现。绑定（也叫调用）可以是指确定函数之间的调用关系、也可以是指确定某个方法的实参。这种关系的确定不是发生在编译期，而是运行期。

## JDK、JRE、JVM 三者之间的关系

- JDK 是 Java 开发工具包，具备编译功能，包含 JRE 和 JVM。
- JRE 仅仅是运行时类库，主要指 lib 文件夹，不具备编译功能。
- JVM 为字节码文件提供运行环境。

我们编写一个程序，那么首先会用到的是 JDK 提供的编译功能，将其编译成字节码文件，然后通过 JRE 合理地调用 lib 并配合 JVM 提供的运行环境，让程序得以运行。

我们可以将 bin 文件夹看作 JVM，因此 bin + lib = JRE。

## 重载和重写的区别

重载是指在同一个类中，相同的方法名，参数数量、类型、次序不同。

重写是指在子类中，相同的方法名、相同的参数数量、类型、次序。

## 是否可以重写 private / static 方法

不能重写。

能重写的方法一定是在继承后，子类能够看到的，因此 `private` 不能被重写。

而 `static` 方法是在编译期发生绑定，而重写的方法是希望绑定发生在运行时，故 `static` 方法也不能被重写。

## static 关键字的作用

- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份；
- 静态方法：静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字；
- 静态语句块：静态语句块在类初始化时运行一次；
- 静态内部类：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法；
- 初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。

## super 关键字的作用

- 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。
- this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

## 构造方法有哪些特性

名字与类名相同。

没有返回值，但不能用 `void` 声明构造函数。

生成类的对象时自动执行，无需调用。

## 一个不做事且无参构造方法有什么作用

Java 程序在执行子类的构造方法之前，如果没有用 `super` 调用父类特定的构造方法，则会调用父类中 "没有参数的构造方法"。

因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 `super` 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。

解决办法是在父类里加上一个不做事且没有参数的构造方法。

## Java 创建对象的几种方式

- 用 `new` 关键字创建对象。需要使用构造器。

- 使用反射机制创建对象。用 `Class` 类或 `Constructor` 类的 `newInstance()` 方法。

- 通过 `Object` 类的 `clone` 方法。需要实现 `Cloneable` 接口，重写 `Object` 类的 `clone()` 方法。

- 使用反序列化。


## 抽象类和接口有什么区别

- 接口只有定义，不能有方法的实现，Java 1.8 中可以定义 `default` 方法体。抽象类可以有定义与实现，方法可在抽象类中实现。

- 实现接口的关键字为 `implements`，继承抽象类的关键字为 `extends`。
- 一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。

## 抽象类必须要有抽象方法吗

不需要。

## 抽象类能用 final 修饰吗

不能，被 final 修饰就不能被继承了，因此抽象方法就无法得以实现。

## 静态变量和实例变量的区别

- 实例变量是属于某个对象的属性，必须创建了实例对象，其中的实例变量才会分配空间，才能使用这个实例变量。

- 静态变量不属于任何的实例对象，而是属于类，也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。


## 阅读程序并分析结果

```java
short s1 = 1; s1 = s1 + 1;	// 错误
short s1 = 1; s1 += 1;		// 正确
```

`s1 = s1 + 1` 报错，因为 `s1 + 1` 结果是 `int` 类型，等号左边是 `short` 类型，所以要强转。

因为 `+=` 在 Java 中进行了特殊处理，所以不会报错。

## == 和 equals 的区别

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

- 基本类型：比较的是值是否相同；
- 引用类型：比较的是引用是否相同；

而 equals 比较的一直他们的值是否相同。

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。

## hashCode 相同 equals 也一定为 true 吗

不对，两个对象的 hashCode() 相同，equals() 不一定 true。

因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。

## 为什么重写 equals 也要重写 hashCode 方法

重写 hashCode 是为了加快大数据量中的查找匹配。

## Integer 和 int 的区别

- `Integer` 是 `int` 的包装类，`int` 是基本数据类型。
- `Integer` 变量必须实例化后才能使用，`int` 变量不需要。
- `Integer` 实际是对象的引用，指向 `new` 的 `Integer` 对象，`int` 是直接存储数据值。
- `Integer` 的默认值是 `null`，`int` 的默认值是 `0`。

## switch 语句能否作用在 byte 上

由于 `byte`、`short`、`char` 都可以隐含转换为 `int`，所以这些类型以及这些类型的包装类型也是可以的。

显然 `long` 和 `String` 类型都不符合 `switch` 的语法规定，并且不能被隐式转换成 `int` 类型，所以它们不能作用于 `switch` 语句中。

## final、finally、finalize 的区别

`final` 用于申明属性，方法和类，表示属性不可变，方法不可以被覆盖，类不可以被继承。

`finally` 是异常处理的一部分，只能在 `try` / `catch` 语句中，表示这个语句最终一定会被执行。

`finalize` 是 `Object` 类的一个方法，它在垃圾回收机制执行的时候会被调用，用于回收对象。

## String、StringBuilder、StringBuffer 的区别

String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。

StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是 *线程安全* 的，而 StringBuilder 是 *非线程安全* 的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。

## 阅读程序并分析结果

```java
String str = "i";					// 分配到常量池中
String str = new String("i");		// 分配到堆内存中
```

## float f = 3.4 是否正确

不正确。3.4 是双精度。需要使用 `float f = (float) 3.4`。

## final 修饰 StringBuffer 还可以 append 吗

不能。final 修饰的东西是不能改变的。

## 什么是 Java 的序列化，如何实现

对象序列化是一个用于将对象状态转换为字节流的过程，可以将其保存到磁盘文件中或通过网络发送到任何其他程序。从字节流创建对象的相反的过程称为反序列化。创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。序列化是为了解决在对象流进行读写操作时所引发的问题。

序列化的实现：

1. 将需要被序列化的类实现 Serializable 接口，该接口没有需要实现的方法，只是用于标注该对象是可被序列化的，
2. 然后使用一个输出流（如：FileOutputStream）来构造一个 ObjectOutputStream 对象，
3. 接着使用 ObjectOutputStream 对象的 writeObject(Object obj) 方法可以将参数为 obj 的对象写出，
4. 要恢复的话则使用输入流。

## 什么情况下需要序列化

（1）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；

（2）当你想用套接字在网络上传送对象的时候；

（3）当你想通过 RMI 传输对象的时候。

## Java 的泛型是如何工作

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。

例如：`List<String>` 在运行时仅用一个 List 来表示。这样做的目的，是确保能和 Java 5 之前的版本开发二进制类库进行兼容。

类型擦除是指泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。

在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `< T >` 则会被转译成普通的 Object 类型，如果指定了上限如 `< T extends String >` 则类型参数就被替换成类型上限 String。

## 什么是泛型中的限定通配符和非限定通配符

限定通配符对类型进行了限制。

有两种限定通配符：

- 一种是 `< ? extends T >` 它通过确保类型必须是 T 的子类来设定类型的上界
- 另一种是`< ? super T >` 它通过确保类型必须是 T 的父类来设定类型的下界。

泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。

另一方面 `< ? >` 表示了非限定通配符，因为 `< ? >` 可以用任意类型来替代。

## 什么是 Java 序列化

Java 序列化是为了保存各种对象在内存中的状态，并且可以把保存的对象状态再读出来。

## transient 关键字的作用

对于不想进行序列化的变量，使用 transient 关键字修饰。

transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化。

当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。

transient 只能修饰变量，不能修饰类和方法。

## 什么是反射

反射是 *在运行状态中*，对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

Class 和 `java.lang.reflect` 一起对反射提供了支持，`java.lang.reflect` 类库主要包含了以下三个类：

1. Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
2. Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
3. Constructor ：可以用 Constructor 创建新的对象。

## 反射有哪些应用场景

工厂模式，使用反射机制，根据全限定类名获得某个类的 Class 实例。

## 反射的优缺点

优点：

- 运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度；

 缺点：

- 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- 内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

## 什么是动态代理

动态代理是运行时动态生成代理类。

这个新类（动态代理类）不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新功能。

## 动态代理有哪些应用场景

Spring 的 AOP 、加事务、加权限、加日志。

## 怎么实现动态代理

```java
//: typeinfo/SimpleDynamicProxy.java
import java.lang.reflect.*;

class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;
    public DynamicProxyHandler(Object proxied) {
        this.proxied = proxied;
    }
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("**** proxy: " + proxy.getClass() +
                        ", method: " + method + ", args: " + args);
        if(args != null)
            for(Object arg : args)
                System.out.println("    " + arg);
        return method.invoke(proxied, args);
    }
}

class SimpleDynamicProxy {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse("bonobo");
    }
    public static void main(String[] args) {
        RealObject real = new RealObject();
        consumer(real);
        // Insert a proxy and call again:
        Interface proxy = (Interface)Proxy.newProxyInstance(
            Interface.class.getClassLoader(),
            new Class[]{ Interface.class },
            new DynamicProxyHandler(real));
        consumer(proxy);
    }
} /* Output: (95% match)
doSomething
somethingElse bonobo
**** proxy: class $Proxy0, method: public abstract void Interface.doSomething(), args: null
doSomething
**** proxy: class $Proxy0, method: public abstract void Interface.somethingElse(java.lang.String),
args: [Ljava.lang.Object;@42e816
    bonobo
somethingElse bonobo
*///:~
```

## try-catch-finally 中哪个部分可以省略

catch 和 finally 都可以被省略，但是不能同时省略。

也就是说有 try 的时候，必须后面跟一个 catch 或者 finally。

## finally 块中的代码什么时候被执行

由于程序执行 return 就意味着结束对当前函数的调用并跳出这个函数体，因此任何语句要执行都只能在 return 前执行（除非碰到 exit 函数），因此 finally 块里的代码也是在 return 之前执行的。

此外，如果 try-finally 或者 catch-finally 中都有 return，那么 finally 块中的 return 将会覆盖别处的 return 语句，最终返回到调用者那里的是 finally 中 return 的值。

## 如果 catch 中 return 了，finally 还会执行吗

finally 一定会执行，即使是 catch 中 return 了，catch 中的 return 会等 finally 中的代码执行完之后，才会执行。

## Error 和 Exception 的区别

Error 类和 Exception 类的父类都是 Throwable 类。

主要区别如下：

- Error 类：一般是指与虚拟机相关的问题
  - 如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。
  - 这类错误将会导致应用程序中断，仅靠程序本身无法恢复和预防；
- Exception 类：分为运行时异常和受检查的异常。

## 运行时异常与受检异常的区别

- 运行时异常：可以编译通过，但是一运行就停止了，程序不会自己处理；
  - 如：空指针异常、指定的类找不到、数组越界、方法传递参数错误、数据类型转换错误。

- 受检查异常：要么用 try-catch 捕获，要么用 throws 声明抛出，交给父类处理。

## throw 和 throws 的区别

- throw 是真实抛出一个异常。throws 是声明可能会抛出一个异常。
- throw 在方法体内部，throws 在方法声明后面。
- throw 由方法体内部的语句处理。throws 由该方法的调用者处理。

## 常见的异常类有哪些

- NullPointerException 空指针异常
- ClassNotFoundException 指定类不存在
- NumberFormatException 字符串转换为数字异常
- IndexOutOfBoundsException 数组下标越界异常
- ClassCastException 数据类型转换异常
- FileNotFoundException 文件未找到异常
- NoSuchMethodException 方法不存在异常
- IOException IO 异常
- SocketException Socket 异常

## 主线程可以捕获到子线程的异常吗

线程设计的理念：“线程的问题应该线程自己本身来解决，而不要委托到外部”。

正常情况下，如果不做特殊的处理，在主线程中是不能够捕获到子线程中的异常的。

如果想要在主线程中捕获子线程的异常，我们可以用如下的方式进行处理，使用 Thread 的静态方法

```java
Thread.setDefaultUncaughtExceptionHandler(new MyUncaughtExceptionHandle());
```

## Java 中的 IO 流的分类

- 按功能分：输入流、输出流
- 按类型分：字节流、字符流

## 说几个 IO 流的实现

| 抽象类 | 输入流      | 输出流       |
| ------ | ----------- | ------------ |
| 字节流 | InputStream | OutputStream |
| 字符流 | Reader      | Writer       |

| 实现类 | 输入流               | 输出流                |
| ------ | -------------------- | --------------------- |
| 字节流 | ByteArrayInputStream | ByteArrayOutputStream |
| 字符流 | CharArrayReader      | CharArrayWriter       |

## 字节流和字符流有什么区别

字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。

## BIO、NIO、AIO 有什么区别

- BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
- NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
- AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

## 如何实现对象的克隆

- 实现 `Cloneable` 接口并重写 `Object` 类中的 `clone()` 方法；

- 实现 `Serializable` 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的 *深克隆*。


## 深克隆和浅克隆的区别

- 浅拷贝：对于仅仅是复制了引用（地址）。

- 深拷贝：在堆中重新分配内存，拥有不同的地址，但是值是一样的，复制后的对象与原来的对象完全隔离，互不影响。

## 创建线程的 3 种方式

- 继承 Thread 重写 run 方法；
- 实现 Runnable 接口；
- 实现 Callable 接口。

## Runnable 和 Callable 的区别

Runnable 没有返回值，Callable 可以拿到有返回值，Callable 可以看作是 Runnable 的补充。

## 线程状态及转换

- NEW 尚未启动
- RUNNABLE 正在执行中
- BLOCKED 阻塞的（被同步锁或者 IO 锁阻塞）
- WAITING 永久等待状态
- TIMED_WAITING 等待指定的时间重新被唤醒的状态
- TERMINATED 执行完成

## sleep() 和 wait() 的区别

所属的类不同：sleep() 来自 Thread，wait() 来自 Object。

释放锁：sleep() 不释放锁；wait() 释放锁。

用法不同：sleep() 时间到会自动恢复；wait() 可以使用 notify() / notifyAll() 直接唤醒。

## notify() 和 notifyAll() 的区别

notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。

notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。

notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。

## run() 和 start() 的区别

- start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。
- run() 可以重复调用，而 start() 只能调用一次。

## execute() 和 submit() 的区别

- execute()：只能执行 Runnable 类型的任务。
- submit()：可以执行 Runnable 和 Callable 类型的任务。

Callable 类型的任务可以获取执行的返回值，而 Runnable 执行无返回值。

## 怎么保证多线程的运行安全

- 使用安全类，比如 java.util.concurrent 下的类。
- 使用自动锁 synchronized。
- 使用手动锁 Lock。

## Java 线程同步的几种方法

1. 使⽤ Synchronized 关键字；

2. wait 和 notify；

3. 使⽤特殊域变量 volatile 实现线程同步；

4. 使⽤可重⼊锁实现线程同步；

5. 使⽤阻塞队列实现线程同步；

6. 使⽤信号量 Semaphore。

## 谈谈对 ThreadLocal 的理解

ThreadLocal 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

## 在哪些场景下会使用到 ThreadLocal

ThreadLocal 的经典使用场景是数据库连接和 Session 管理等。

## 说一说对于 synchronized 关键字的了解

synchronized 是由一对 monitorenter/monitorexit 指令实现的，monitor 对象是同步的基本实现单元。

在 Java 1.6 之前，monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作，性能也很低。

但在 Java 1.6 的时候，Java 虚拟机对此进行了改进，提供了三种不同的 monitor 实现，也就是常说的三种不同的锁：

- 偏向锁（Biased Locking）
- 轻量级锁
- 重量级锁

从而，大大改进了其性能。

## synchronized 锁升级的原理

在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，JVM 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量
级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。

## synchronized 和 ReentrantLock 的区别

synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，但是在 Java 1.6  中对 synchronized 进行了非常多的改进。

- ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作；
- ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；
- ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。

## synchronized 和 volatile 的区别

- volatile 是变量修饰符；synchronized 可以修饰类、方法、代码段。
- volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。
- volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。
- volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。

## synchronized 和 Lock 的区别

- synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
- synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unlock() 去释放锁就会造成死锁。
- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

## 谈一下你对 volatile 关键字的理解

volatile 关键字是用来保证有序性和可见性的。这跟 Java 内存模型有关。

我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU 也会做重排序的，这样做是为了减少流水线阻塞，提高 CPU 的执行效率。

这就需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知道对不对了，所以有 happens-before 规则，其中有条就是 volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作、有序性实现的是通过插入内存屏障来保证的。

被 volatile 修饰的共享变量，就具有了以下两点特性：

- 保证了不同线程对该变量操作的内存可见性;
- 禁止指令重排序。

## 说下对 ReentrantReadWriteLock 的理解

ReentrantReadWriteLock 允许多个读线程同时访问，但是不允许写线程和读线程、写线程和写线程同时访问。

读写锁内部维护了两个锁：一个是用于读操作的 ReadLock，一个是用于写操作的 WriteLock。

读写锁 ReentrantReadWriteLock 可以保证多个线程可以同时读，所以在读操作远大于写操作的时候，读写锁就非常有用了。

ReentrantReadWriteLock 基于 AQS 实现，它的自定义同步器（继承 AQS）需要在同步状态 state 上维护多个读线程和一个写线程，该状态的设计成为实现读写锁的关键。

ReentrantReadWriteLock 很好的利用了高低位。来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。

ReentrantReadWriteLock 的特点：

- 写锁可以降级为读锁，但是读锁不能升级为写锁；

- 不管是 ReadLock 还是 WriteLock 都支持 Interrupt，语义与 ReentrantLock 一致；

- WriteLock 支持 Condition 并且与 ReentrantLock 语义一致，而 ReadLock 则不能使用 Condition，否则抛出 UnsupportedOperationException 异常；
- 默认构造方法为非公平模式 ，开发者也可以通过指定 fair 为 true 设置为公平模式 。

升降级

- 读锁里面加写锁，会导致死锁；
- 写锁里面是可以加读锁的，这就是锁的降级。

## 乐观锁的两种常见实现方式

乐观锁一般会使用版本号机制或者 CAS 算法实现。

**版本号机制**

一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加 1。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

**CAS 算法**

即 compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS 算法涉及到三个操作数：

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。

## 乐观锁的缺点

**ABA 问题**

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 “ABA” 问题。

JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

**循环时间长开销大**

自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一：它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二：它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。

**只能保证一个共享变量的原子操作**

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。

但是从 JDK 1.5 开始，提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。所以我们可以使用锁或者利用 AtomicReference 类把多个共享变量合并成一个共享变量来操作。

## CAS 和 synchronized 的使用场景

简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）。

对于资源竞争较少（线程冲突较轻）的情况，使用 synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。

对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。

## 简单说下对 Java 中的原子类的理解

这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。所以，所谓原子类说简单点就是具有原子操作特征的类。

并发包 java.util.concurrent 的原子类都存放在 java.util.concurrent.atomic 下。

根据操作的数据类型，可以将 JUC 包中的原子类分为 4 类：

基本类型

- AtomicInteger：整型原子类
- AtomicLong：长整型原子类
- AtomicBoolean ：布尔型原子类

数组类型：使用原子的方式更新数组里的某个元素

- AtomicIntegerArray：整型数组原子类
- AtomicLongArray：长整型数组原子类
- AtomicReferenceArray ：引用类型数组原子类

引用类型

- AtomicReference：引用类型原子类
- AtomicStampedReference：原子更新引用类型里的字段原子类
- AtomicMarkableReference ：原子更新带有标记位的引用类型

对象的属性修改类型

- AtomicIntegerFieldUpdater：原子更新整型字段的更新器
- AtomicLongFieldUpdater：原子更新长整型字段的更新器
- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。

## atomic 的原理是什么

Atomic 包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。

## 说下对同步器 AQS 的理解

AQS 的全称为：AbstractQueuedSynchronizer，这个类在 java.util.concurrent.locks 包下面。

AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如：我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。

当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。

## AQS 的原理是什么

AQS 核心思想是：如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。

如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 *CLH 队列锁* 实现的，即将暂时获取不到锁的线程加入到队列中。

## AQS 对资源的共享模式有哪些

Exclusive（独占）：只有一个线程能执行，如：ReentrantLock，又可分为公平锁和非公平锁；

Share（共享）：多个线程可同时执行，如：CountDownLatch、Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock。

## 说几个继承 AQS 需要重写的方法

AQS 底层使用了模板方法模式。使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。

将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。

- isHeldExclusively() ：该线程是否正在独占资源。只有用到 condition 才需要去实现它。
- tryAcquire(int) ：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。
- tryRelease(int) ：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。
- tryAcquireShared(int) ：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int) ：共享方式。尝试释放资源，成功则返回 true，失败则返回 false。

## 说下对信号量 Semaphore 的理解

synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore (信号量)可以指定多个线程同时访问某个资源。

- 执行 acquire 方法阻塞，直到有一个许可证可以获得然后拿走一个许可证；
- 每个 release 方法增加一个许可证，这可能会释放一个阻塞的 acquire 方法。

然而，其实并没有实际的许可证这个对象，Semaphore 只是维持了一个可获得许可证的数量。

Semaphore 经常用于限制获取某种资源的线程数量。

当然一次也可以一次拿取和释放多个许可证，不过一般没有必要这样做。

除了 acquire方法（阻塞）之外，另一个比较常用的与之对应的方法是 tryAcquire 方法，该方法如果获取不到许可就立即返回 false。

## CountDownLatch 和 CyclicBarrier 的区别

- CountDownLatch 是计数器，只能使用一次，而 CyclicBarrier 的计数器提供 reset 功能，可以多次使用。
- 对于 CountDownLatch 来说，重点是 “一个线程（多个线程）等待”，而其他的 N 个线程在完成 “某件事情” 之后，可以终止，也可以等待。而对于 CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。
- CountDownLatch 是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而 CyclicBarrier 更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。

CountDownLatch 应用场景：

- 某一线程在开始运行前等待 n 个线程执行完毕：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。
- 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。
- 死锁检测：一个非常方便的使用场景是，你可以使用 n 个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。

CyclicBarrier 应用场景：

- CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如：我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。

## 为什么要使用线程池

线程池提供了一种限制和管理资源（包括执行一个任务）的方式。

每个线程池还维护一些基本统计信息，例如：已完成任务的数量。

使用线程池的好处

- 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；
- 提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行；
- 提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 创建线程池的参数有哪些

- corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前 poolSize < corePoolSize 时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads() 方法，线程池会提前创建并启动所有基本线程。
- maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。
- keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。
- TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。
- workQueue（任务队列）：用于保存等待执行的任务的阻塞队列。

## 创建线程池的 7 种方式

newSingleThreadExecutor()：它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目；

newCachedThreadPool()：它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列；

newFixedThreadPool(int nThreads)：重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads；

newSingleThreadScheduledExecutor()：创建单线程池，返回 ScheduledExecutorService，可以进行定时或周期性的工作调度；

newScheduledThreadPool(int corePoolSize)：和 newSingleThreadScheduledExecutor()类似，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程；

newWorkStealingPool(int parallelism)：这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建 ForkJoinPool，利用 Work-Stealing 算法，并行地处理任务，不保证处理顺序；

ThreadPoolExecutor()：是最原始的线程池创建，上面 1-3 创建方式都是对 ThreadPoolExecutor 的封装。

## 线程池都有哪些状态

- RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。
- SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务。
- STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。
- TIDYING：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。
- TERMINATED：terminated()方法结束后，线程池的状态就会变成这个。

## 设置线程池中的的线程数一般考虑哪些问题

**线程池中线程执行任务的性质**

计算密集型的任务比较占 cpu，所以一般线程数设置的大小 等于或者略微大于 cpu 的核数；但 IO 型任务主要时间消耗在 IO 等待上，cpu 压力并不大，所以线程数一般设置较大。

**cpu 使用率**

当线程数设置较大时，会有如下几个问题：第一，线程的初始化，切换，销毁等操作会消耗不小的 cpu 资源，使得 cpu 利用率一直维持在较高水平。第二，线程数较大时，任务会短时间迅速执行，任务的集中执行也会给 cpu 造成较大的压力。第三， 任务的集中支持，会让 cpu 的使用率呈现锯齿状，即短时间内 cpu 飙高，然后迅速下降至闲置状态，cpu 使用的不合理，应该减小线程数，让任务在队列等待，使得 cpu 的使用率应该持续稳定在一个合理，平均的数值范围。所以 cpu 在够用时，不宜过大，不是越大越好。可以通过上线后，观察机器的 cpu 使用率和 cpu 负载两个参数来判断线程数是否合理。

**内存使用率**

线程数过多和队列的大小都会影响此项数据，队列的大小应该通过前期计算线程池任务的条数，来合理的设置队列的大小，不宜过小，让其不会溢出，因为溢出会走拒绝策略，多少会影响性能，也会增加复杂度。

**下游系统抗并发能力**

多线程给下游系统造成的并发等于你设置的线程数，例如：如果是多线程访问数据库，你就考虑数据库的连接池大小设置，数据库并发太多影响其 QPS，会把数据库打挂等问题。如果访问的是下游系统的接口，你就得考虑下游系统是否能抗的住这么多并发量，不能把下游系统打挂了。

## 说下对 fork 和 join 并行计算框架的理解

Fork/Join 并行计算框架主要解决的是分治任务。分治的核心思想是 “分而治之”：将一个大的任务拆分成小的子任务的结果聚合起来从而得到最终结果。

Fork/Join 并行计算框架的核心组件是 ForkJoinPool。

- ForkJoinPool 支持任务窃取机制，能够让所有的线程的工作量基本均衡，不会出现有的线程很忙，而有的线程很闲的情况，所以性能很好。
- ForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和 “窃取任务” 分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。

## JDK 中提供了哪些并发容器

- ConcurrentHashMap：线程安全的 HashMap；
- CopyOnWriteArrayList：线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector；
- ConcurrentLinkedQueue：高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列；
- BlockingQueue：这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道；
- ConcurrentSkipListMap：跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。

## 谈谈对 CopyOnWriteArrayList 的理解

在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问 List 的内部数据，毕竟读取操作是安全的。

CopyOnWriteArrayList 类的所有可变操作（add，set 等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我们并不需要修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。

从 CopyOnWriteArrayList 的名字就能看出 CopyOnWriteArrayList 是满足 CopyOnWrite 的 ArrayList，所谓 CopyOnWrite 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。

CopyOnWriteArrayList 读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。

CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。

## 谈谈对 BlockingQueue 的理解

阻塞队列（BlockingQueue）被广泛使用在 “生产者-消费者” 问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。

## 谈谈对 ConcurrentSkipListMap 的理解

对于一个单链表，即使链表是有序的，如果我们想要在其中查找某个数据，也只能从头到尾遍历链表，这样效率自然就会很低，跳表就不一样了。跳表是一种可以用来快速查找的数据结构，有点类似于平衡树。它们都可以对元素进行快速的查找。

但一个重要的区别是：对平衡树的插入和删除往往很可能导致平衡树进行一次全局的调整。而对跳表的插入和删除只需要对整个数据结构的局部进行操作即可。

这样带来的好处是：在高并发的情况下，你会需要一个全局锁来保证整个平衡树的线程安全。而对于跳表，你只需要部分锁即可。这样，在高并发环境下，你就可以拥有更好的性能。而就查询的性能而言，跳表的时间复杂度也是 O(logn) 。

跳表的本质是同时维护了多个链表，并且链表是分层的。

## 谈谈对运行时数据区的理解

不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：

- 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
- 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
- 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；
- 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；
- 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。

## 堆和栈的区别是什么

- 功能方面：堆是用来存放对象的，栈是用来存放基本数据类型和堆中的对象的引用的。
- 共享性：堆是线程共享的，栈是线程私有的。
- 空间大小：堆大小远远大于栈。

## 为什么要把堆和栈区分出来呢

功能划分：堆中数据可共享（如共享内存），栈为上下文切换提供了支持。

## JVM 的主要组成部

- 类加载器（ClassLoader）
- 运行时数据区（Runtime Data Area）
- 执行引擎（Execution Engine）
- 本地库接口（Native Interface）

## Java 对象的大小是怎么计算的

对象的引用占据的空间（栈区） + 对象实体占用的空间（堆区）

## 对象的访问定位的两种方式

- 使用句柄
- 使用指针

## 句柄和指针的区别

指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。

这种间接访问对象的模式增强了系统对引用对象的控制。

句柄就是个数字，一般和当前系统下的整数的位数一样，比如 32bit 系统下就是 4 个字节。

## 判断垃圾可以回收的方法有哪些

- 引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；
- 可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。

## 垃圾回收从哪里开始

从 Java 栈开始，根据相互之间的引用关系，以 null 引用或基本类型结束。

## 被标记为垃圾的对象一定会被回收吗

即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于 “缓刑” 阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。

- 第一次标记：如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记；
- 第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。在 `finalize()` 方法中没有重新与引用链建立关联关系的，将被进行第二次标记。

第二次标记成功的对象将真的会被回收，如果对象在 `finalize()` 方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

## Java 中的引用分类哪些类型

- 强引用：发生 GC 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 GC 时返回一个通知。

## 谈谈对内存泄漏的理解

在 Java 中，内存泄漏就是存在一些不会再被使用确没有被回收的对象，这些对象有下面两个特点：

- 这些对象是可达的，即在有向图中，存在通路可以与其相连；
- 这些对象是无用的，即程序以后不会再使用这些对象。

如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。

## 内存泄露的根本原因是什么

长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。

## 举几个可能发生内存泄漏的情况

- 静态集合类引起的内存泄漏；
- 当集合里面的对象属性被修改后，再调用 remove() 方法时不起作用；
- 监听器：释放对象的时候没有删除监听器；
- 各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；
- 内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；
- 单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。

## 尽量避免内存泄漏的方法

- 尽量不要使用 static 成员变量，减少生命周期；
- 及时关闭资源；
- 不用的对象，可以手动设置为 null。

## 常用的垃圾收集算法有哪些

- 标记-清除算法：标记无用对象，然后进行清除回收。
  - 缺点：效率不高，无法清除垃圾碎片。
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
- 复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。
  - 缺点：内存使用率不高，只有原来的一半。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

## 为什么要采用分代收集算法

分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。

因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。

在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如 Http 请求中的 Session 对象、线程、Socket 连接，这类对象跟业务直接挂钩，因此生命周期比较长。

但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String 对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。

在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。

因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。

## 简述分代垃圾回收器是怎么工作的

分代回收器有两个分区：老生代和新生代。

- 新生代默认的空间占比总空间的 1/3；
- 老生代的默认占比是 2/3。

新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：

- 把 Eden + From Survivor 存活的对象放入 To Survivor 区；

- 清空 Eden 和 From Survivor 分区；

- From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。

- 每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。

老生代一般使用标记整理的执行算法：

- 当空间占用到达某个值之后就会触发全局垃圾收回。

以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。

## 什么是浮动垃圾

由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了 “Floating Garbage”，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，并发收集器一般需要 20% 的预留空间用于这些浮动垃圾。

## 垃圾收集器有哪些

新生代回收器：

- Serial：最早的单线程串行垃圾回收器。
- ParNew：是 Serial 的多线程版本。
- Parallel：和 ParNew 收集器类似，多线程，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。

老年代回收器：

- Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。
- Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。
- CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。

整堆回收器：

- G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。

总结：

- 新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；
- 老年代回收器一般采用的是标记-整理的算法进行垃圾回收。

## CMS 垃圾收集器

CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。是使用标记清除算法实现的，整个过程分为四步：

- 初始标记：记录下直接与 root 相连的对象，暂停所有的其他线程，速度很快；
- 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。【这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短】；
- 并发清除：开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

CMS 的优缺点：

- 主要优点：并发收集、低停顿；
- 主要缺点：对 CPU 资源敏感、无法处理浮动垃圾、它使用的回收算法 “标记-清除” 算法会导致收集结束时会有大量空间碎片产生。

## G1 收集器

G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region（这也就是它的名字 Garbage-First的由来）。

垃圾回收的瓶颈：传统分代垃圾回收方式，已经在一定程度上把垃圾回收给应用带来的负担降到了最小，把应用的吞吐量推到了一个极限。但是他无法解决的一个问题，就是 Full GC 所带来的应用暂停。

在一些对实时性要求很高的应用场景下，GC 暂停所带来的请求堆积和请求失败是无法接受的。这类应用可能要求请求的返回时间在几百甚至几十毫秒以内，如果分代垃圾回收方式要达到这个指标，只能把最大堆的设置限制在一个相对较小范围内，但是这样有限制了应用本身的处理能力，同样也是不可接受的。

分代垃圾回收方式确实也考虑了实时性要求而提供了并发回收器，支持最大暂停时间的设置，但是受限于分代垃圾回收的内存划分模型，其效果也不是很理想。

G1 可谓博采众家之长，力求到达一种完美。

- 它吸取了增量收集优点，把整个堆划分为一个一个等大小的区域（region）。内存的回收和划分都以region为单位；
- 同时，它也吸取了 CMS 的特点，把这个垃圾回收过程分为几个阶段，分散一个垃圾回收过程；
- 而且，G1 也认同分代垃圾回收的思想，认为不同对象的生命周期不同，可以采取不同收集方式，因此，它也支持分代的垃圾回收。

为了达到对回收时间的可预计性，G1 在扫描了 region 以后，对其中的活跃对象的大小进行排序，首先会收集那些活跃对象小的 region，以便快速回收空间（要复制的活跃对象少了），因为活跃对象小，里面可以认为多数都是垃圾，所以这种方式被称为 Garbage First（G1）的垃圾回收算法，即：垃圾优先的回收。

## 谈谈你对内存分配的理解

- 对象优先在 Eden 区分配：大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。
- 大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。`-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
- 长期存活的对象将进入老年代：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值。
- 动态对象年龄判定：为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。

## JVM 中的空间分配担保

- 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；
- 如果不成立的话，虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。

## 说一下 JVM 调优的工具

JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。

- jconsole：用于对 JVM 中的内存、线程和类等进行监控；
- jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、GC 变化等。

此外，还有：

- jps ：查看当前 Java 进程
- jstat：显示虚拟机运行数据
- jmap：内存监控
- jhat：分析 heapdump 文件
- jstack：线程快照
- jinfo：虚拟机配置信息

## 如何利用调优工具

1、堆信息查看

- 可查看堆空间大小分配（年轻代、年老代、持久代分配）
- 提供即时的垃圾回收功能
- 垃圾监控（长时间监控回收情况）
- 查看堆内类、对象信息查看：数量、类型等
- 对象引用情况查看

有了堆信息查看方面的功能，我们一般可以顺利解决以下问题：

- 年老代年轻代大小划分是否合理
- 内存泄漏
- 垃圾回收算法设置是否合理

2、线程监控

- 线程信息监控：系统线程数量
- 线程状态监控：各个线程都处在什么样的状态下
- Dump 线程详细信息：查看线程内部运行情况
- 死锁检查

3、 热点分析

- CPU 热点：检查系统哪些方法占用的大量 CPU 时间；
- 内存热点：检查哪些对象在系统中数量最大（一定时间内存活对象和销毁对象一起统计）

这两个东西对于系统优化很有帮助。我们可以根据找到的热点，有针对性的进行系统的瓶颈查找和进行系统优化，而不是漫无目的的进行所有代码的优化。

4、快照

- 快照是系统运行到某一时刻的一个定格。

- 在我们进行调优的时候，不可能用眼睛去跟踪所有系统变化，依赖快照功能，我们就可以进行系统两个不同运行时刻，对象（或类、线程等）的不同，以便快速找到问题。

- 举例说，我要检查系统进行垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进行垃圾回收前后，分别进行一次堆情况的快照，然后对比两次快照的对象情况。

5、内存泄露检查

- 内存泄漏是比较常见的问题，而且解决方法也比较通用，这里可以重点说一下，而线程、热点方面的问题则是具体问题具体分析了。
- 内存泄漏一般可以理解为系统资源（各方面的资源，堆、栈、线程等）在错误使用的情况下，导致使用完毕的资源无法回收（或没有回收），从而导致新的资源分配请求无法完成，引起系统错误。

内存泄漏对系统危害比较大，因为它可以直接导致系统的崩溃。

## 常用的 JVM 调优的参数

- -Xms2g：初始化推大小为 2g；
- -Xmx2g：堆最大内存为 2g；
- -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；
- -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；
- –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
- -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
- -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
- -XX:+PrintGC：开启打印 gc 信息；
- -XX:+PrintGCDetails：打印 gc 详细信息。

## 类加载器的执行过程

类加载器是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。

对于任意一个类，都需要由加载它的类加载器和这个类本身共同确立在 JVM 中的唯一性，每一个类加载器都有一个独立的类名称空间。

类加载过程分为 5 步：

- 加载：根据查找路径找到相应的 class 文件然后导入；
- 检查：检查加载的 class 文件的正确性；
- 准备：给类中的静态变量分配内存空间；
- 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；
- 初始化：对静态变量和静态代码块执行初始化工作。

## 类加载器的分类

- 启动类加载器（Bootstrap ClassLoader）是虚拟机自身的一部分。用来加载 Java_HOME/lib/ 目录（或者被 -Xbootclasspath 参数所指定的路径）中被虚拟机识别的类库；
- 扩展类加载器（Extension ClassLoader）负责加载 lib/ext 目录或 Java.ext.dirs 系统变量指定的路径中的所有类库；
- 应用程序类加载器（Application ClassLoader）负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。

## 双亲委派模型的工作过程

如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。

## 使用双亲委派模型的好处

Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如：类 java.lang.Object，它存放在 rt.jar 中，无论哪一个类加载器需要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类（使用的是同一个类加载器加载的）。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个 java.lang.Object 类，并放在程序的 ClassPath 中，那么系统将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。

## 双亲委派模型的实现

实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法中，逻辑清晰易懂：先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父类加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。

## 怎么实现一个自定义的类加载器

若要实现自定义类加载器，只需要继承 java.lang.ClassLoader 类，并且重写其 findClass() 方法即可。

## 怎么打破双亲委派模型

- 自己写一个类加载器；
- 重写 loadClass() 方法
- 重写 findClass() 方法

这里最主要的是重写 loadClass 方法，因为双亲委派机制的实现都是通过这个方法实现的，先找父加载器进行加载，如果父加载器无法加载再由自己来进行加载，源码里会直接找到根加载器，重写了这个方法以后就能自己定义加载的方式了。

## 哪些场景需要打破双亲委派模型

JNDI 服务，它的代码由启动类加载器去加载，但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用独立厂商实现并部署在应用程序的 classpath 下的 JNDI 接口提供者 (SPI, Service Provider Interface) 的代码，但启动类加载器不可能 “认识” 这些代码，该怎么办？

为了解决这个困境，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器(Thread Context ClassLoader)。

这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个；如果在应用程序的全局范围内都没有设置过，那么这个类加载器默认就是应用程序类加载器。

有了线程上下文类加载器，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型，但这也是无可奈何的事情。

Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。

## 编译期优化和运行期优化

- 编译期优化：
  - 解析与填充符号表的过程
  - 插入式注解处理器的注解处理过程
  - 分析与字节码生成过程
- 编译优化：
  - 方法内联
  - 公共子表达式消除
  - 数组范围检查消除
  - 逃逸分析

## 为何 HotSpot 虚拟机要使用解释器与编译器并存的架构

- 解释器：程序可以迅速启动和执行，消耗内存小 （类似人工，成本低，到后期效率低）；

- 编译器：随着代码频繁执行会将代码编译成本地机器码 （类似机器，成本高，到后期效率高）。

在整个虚拟机执行架构中，解释器与编译器经常配合工作，两者各有优势：

- 当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。
- 在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。
- 当程序运行环境中内存资源限制较大（如部分嵌入式系统），可以使用解释执行节约内存，反之可以使用编译执行来提升效率。
- 解释执行可以节约内存，而编译执行可以提升效率。

因此，在整个虚拟机执行架构中，解释器与编译器经常配合工作。

## Java 中常用的容器有哪些

Java 容器分为 Collection 和 Map 两大类，其下又有很多子类。

## Collection 和 Collections 有什么区别

`Collection` 是一个集合 *接口*，它提供了对集合对象进行基本操作的通用接口方法，所有集合都是它的子类，比如 `List`、`Set` 等。

`Collections` 是一个 *包装类*，包含了很多静态方法，不能被实例化，就像一个工具类，比如提供的排序方法： `Collections. sort(list)`。

## HashMap 的实现原理

HashMap 基于 Hash 算法实现的，我们通过 put(key,value)存储，get(key)来获取。当传入 key 时，HashMap 会根据 key. hashCode() 计算出 hash 值，根据 hash 值将 value 保存在 bucket 里。

当计算出的 hash 值相同时，我们称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同 hash 值的 value。

当 hash 冲突的个数比较少时使用链表，否则使用红黑树。

## HashSet 的实现原理

HashSet 是基于 HashMap 实现的，HashSet 底层使用 HashMap 来保存所有元素，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。

## HashMap 与 HashTable 的区别

从 HashTable 类的注释可以了解到，HashTable 是保留类 *不建议使用*。

- 存储：HashMap 运行 key 和 value 为 null，而 HashTable 不允许。
- 线程安全：HashTable 是线程安全的，而 HashMap 是非线程安全的。

推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。

## ArrayList 和 Vector 的区别

- 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
- 性能：ArrayList 在性能方面要优于 Vector。
- 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。

## 哪些集合类是线程安全的

Vector、HashTable、Stack 都是线程安全的，而像 HashMap 则是非线程安全的。

不过在 JDK 1.5 之后随着 Java. util. concurrent 并发包的出现，它们也有了自己对应的线程安全类，比如 HashMap 对应的线程安全类就是 ConcurrentHashMap。

