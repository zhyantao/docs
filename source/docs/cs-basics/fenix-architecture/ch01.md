# 服务架构的演进

服务架构演进大致经历了原始分布式架构、单体架构、SOA 架构、微服务架构、服务网格架构和无服务架构。

由于一台计算机的资源十分有限（16 位寻址、5 MHz 时钟频率、128 KB 内存地址空间），人们开始想象用多台计算机共同完成任务，这是**早期分布式的尝试**。

在早期尝试中的标志性事件是国际开放标准组织（OSF）和业界主流计算机厂商共同制定了“**分布式运算环境（DCE）**”的分布式技术体系。

OSF 的愿景是**使分布式环境中的服务调用、资源访问、数据存储等操作尽可能透明化、简单化，从而使开发人员不必过于关注他们访问的方法或其他资源是位于本地还是远程**。

因此，DCE 制定了包含一套相对完整的分布式服务组件规范和参考实现：

- 源自 NCA 的远程服务调用规范（DCE/RPC）；
- 源自 AFS 的分布式文件系统（DCE/DFS）；
- 源自 Kerberos 的服务认证规范；
- 通用唯一标识符（UUID） 也是在 DCE 中发明的。

但是这种复杂的设计限制了它的发展，而且调用远程方法相比于调用本地方法有更多的**局限性**：

- 远程方法不能依靠以内联为代表的传统编译优化来提升速度
- 网络环境下：
  
  - 远程服务在哪里（服务发现）
  - 有多少个（负载均衡）
  - 网络出现分区、超时或者服务出错了怎么办（熔断、隔离、降级）
  - 方法的参数与返回值如何表示（序列化协议）
  - 信息如何传输（传输协议）
  - 服务权限如何管理（认证、授权）
  - 如何保证通信安全（网络安全层）
  - 如何调用不同机器的服务返回相同的结果（分布式数据一致性）

**某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自食苦果。**

后随着单机处理能力的稳步上升，一些在分布式中遇到的问题，在单体架构中通常不会出现。

单体是一个完全不可分割的整体，这种看法是不恰当的。

从纵向来看，不论是单体架构（也叫巨石系统）还是微服务，抑或是其他架构风格，**分层是普遍的**。
收到的外部请求在各层之间以不同形式的数据结构进行流转传递。

从横向来看，单体架构也支持按照技术、功能、职责等维度将代码**拆分为各个模块**。
在扩展能力上，也可以用负载均衡器之后部署若干个相同的副本，来达到分摊流量的效果。

单体架构的**缺陷**，不在于如何拆分，而在于拆分之后的自治与隔离能力上（代码是否能够运行在不同的进程中）。

如果任何一部分代码出现缺陷，过度消耗了进程空间的资源，造成的影响可能也是全局性的，难以隔离的，
比如内存泄漏、线程爆炸、阻塞、死循环等。

更高层的公共资源发生问题，比如端口号或数据库连接池泄漏，将会影响整台机器，甚至集群中的其他单体副本。

从可维护性上讲，单体系统的升级和修改需要制定专门的停机更新计划，做灰度发布，A/B 测试。

单体架构还面对技术异构的困难，每个模块的代码通常需要使用一样的程序语言。

单体架构只能尽可能低地让意外发生，以维持系统的**稳定性**。而**出错是必然**，也才出现了后面的架构风格。

面向服务架构（SOA）：

- 烟囱式架构（又名信息烟囱，信息孤岛）：假设模块之间没有任何交集，不现实，**已被淘汰**；
- 微内核架构（又称插件式架构）：公共资源（也叫主数据，如人员、组织、权限等）放在内核中，具体业务已插件模块的形式存在。
  它很适合桌面应用程序和 Web 应用程序，因为对于平台型应用，我们希望将新特性或新功能及时加入系统。
  **局限性**在于假设各个插件之间不能直接交互，不适用于企业信息系统或互联网应用；
- 事件驱动架构：解决了为内核架构的局限性，既能拆分成独立的子系统，又能让子系统之间顺畅地通信。
  它在子系统之间建立一套**事件队列管道**，来自系统外部的消息以事件的形式发送至管道中。
  各个子系统可以从管道中获取自己感兴趣、能够处理的事件消息，也可以新增或修改其中的附加信息。
  如此，每一条消息都是独立的、高度解耦的但又能与其他处理者通过事件管道进行交互。

后面因为 SOA 变得越来越复杂，已经不能简单视为一种架构风格，它对软件设计提出了一系列方法论：

- 服务的封装性、自治、松耦合、可重用、可组合、无状态；
- 采用 SOAP 作为远程服务调用协议；
- 依靠 SOAP 协议族（WSDL、UDDI、WS-*）完成服务的发布、发现、治理
- 利用企业服务总线（ESB）的消息管道实现各子系统之间的交互；
- 令各服务在 ESB 的调度下，无需相互依赖就能相互通信，进而实现业务流程编排（BPM）；
- 使用服务数据对象（SDO）来访问和表示数据；
- 使用服务组件架构（SCA）来定义服务封装的形式和服务运行的容器；
- ……

过于严格的规范定义带来过度的复杂性，而构建在 SOAP 之上的 ESB、BPM、SCA、SDO 等诸多上层建筑进一步加剧了复杂性，
最终导致 SOAP **逐渐被边缘化**。取而代之的是**草根框架：Spring、Hibernate**。

微服务是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建。
各个服务可以采用不同的编程语言、不同的存储技术、运行在不同的进程中。

服务采用轻量级的通信机制和自动化的部署机制实现通信和运维。

微服务提倡以“**实践标准**”代替“规范标准”。因此，针对分布式中的每个问题，都有许多针对性的解决方案，比如：

- 远程服务调用：RMI（Sun/Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、
  Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC、REST 等；
- 服务发现：Eureka（Netflix）、Consul（HashiCorp）、Nacos（阿里巴巴）、ZooKeeper（Apache）、
  etcd（CoreOS）、CoreDNS（CNCF）等；
- ……

因此，“解决什么问题，就引入什么工具，熟悉什么技术，用使用什么框架”是微服务中的一大特征。
但是，微服务对架构能力要求较高，需要了解各个工具的利弊，做出权衡。

分布式架构中遇到的诸如注册发现、跟踪治理、负载均衡、传输通信等，既有硬件解决方案，也有软件解决方案。硬件方案比如：

- 系统伸缩扩容：购买新的服务器，部署副本；
- 负载均衡：布置负载均衡器，选择均衡算法；
- 解决传输安全问题：布置 TLS 传输链路，配置好 CA 证书；
- 服务发现：设置 DNS 服务器；
- ……

相比于硬件，软件解决方案更加灵活。上面这些硬件，可以使用**虚拟化技术或容器化技术**来实现。
早期的容器和虚拟化技术用来：软件定义网络（SDN）、软件定义存储（SDS）等。

因此，我们可以采用**虚拟化的基础设施**解决在分布式系统中遇到的问题。
可供选择的工具，比如 Kubernetes、Spring Cloud 等。

至此，软件和硬件之间的界限变得越来越模糊。

一旦虚拟化的基础设施能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能从软件层面剥离，悄无声息地在硬件基础设施中解决，
让软件只关注业务，真正围绕业务能力构建团队和产品。
因此，DCE 设想的“透明式的分布式应用”成为可能。这种软硬一体解决架构问题的方式被称为**云原生**。

Kubernetes **局限性**在于难以对处于应用系统和基础设施边缘的问题精细化管理。
比如下图中微服务 A 调用了微服务 B 的两个服务，是否要熔断？

```{figure} ../../../_static/images/fenix-001.png
:height: 150px
:name: fenix-001

是否要熔断对服务 B 的访问？
```

这在 K8s 中很难解决，但是 Spring Cloud 就相对比较容易解决，因为 Spring Cloud 自定义程度更高。

需要注意的是，基础设施是针对整个容器来管理的，粒度相对粗犷，只能到容器层面，对单个远程服务则难以有效管控。
因此，针对**更加精细化的管理**，出现了**服务网格的边车代理模式**。

虚拟化场景中的边车指的是由系统自动在服务容器（通常指 Kubernetes 中的 Pod。
一个 Pod 由一个或多个容器组成 [^ref2112122001]）中注入的一个通信代理服务器，相当于那个挎斗。
在应用毫无感知的情况下，接管应用所有的对外通信（包含数据平面通信和控制平面通信）。
通过边车代理模式，实现了精细化管理。

[^ref2112122001]: https://zhuanlan.zhihu.com/p/32618563

2014 年亚马逊发布了 Lambda **无服务计算平台**。它只涉及后端设施和函数两个概念：

- 后端设施：数据库、消息队列、日志、存储等技术组件；
- 函数：业务逻辑代码。

无服务计算平台比较适合短连接、无状态、事件驱动的程序：Web 资讯类网站、小程序、公共 API 服务。
不适合长连接、依赖服务状态、、响应速度较高的程序：游戏。而且，程序的冷启动时间也是耗时的。
