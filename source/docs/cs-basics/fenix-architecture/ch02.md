# 访问远程服务

## 远程服务调用

分析访问远程服务的规则时，一般经常和调用本地服务作对比。

因为本地服务调用无法解决跨越两个内存地址空间进行方法调用。
因此出现了进程间通信（IPC），常用的解决方法有：(具名)管道、信号、信号量、消息队列、共享内存、本地套接字接口。

构建分布式服务时，需要注意以下认知误区：

- 网络是可靠的
- 延迟是不存在的
- 带宽是无限的
- 网络是安全的
- 拓扑结构是一成不变的
- 总会有一个管理员
- 不必考虑传输成本
- 网络都是同质化的

构建分布式服务时，需要考虑三个基本问题：

- 如何表示数据（就是我们常说的序列化和反序列化）
- 如何传递数据（网络各分层之间如何交换数据，需要考虑异常、超时、安全、认证、授权、事务等）
- 如何表示方法（最简单的方式是给每个方法一个唯一的 UUID）

**没有一个完美的协议或框架**能够解决所有分布式中碰到的问题：

- 考虑分布式中面向对象编程：RMI、.NET Remoting
- 优先考虑性能：gRPC、Thrift
- 优先考虑简单易用：JSON-PRC

因此在做选择时，需要权衡利弊。

## REST 设计风格

[REST](https://icyfenix.cn/architect-perspective/general-architecture/api-style/rest.html) 
风格和远程服务调用有些相似，但是本质上不同。两者最大的不同是抽象目标不同：

- 远程服务调用：面向过程的思想
- REST 风格：面向资源的思想

REST 不是一种远程服务调用协议，甚至，它就不是一个协议，因此也就没有过多约束。

REST 和 RPC 是两种主流的远程调用方式，其侧重范围略有不同：

- RPC：分布式对象、提升性能、简化调用复杂性
- REST：浏览器端（也可以用于移动端、桌面端，只要支持 HTTP 就行，但是性能不高）

因为 REST 风格基于 HTTP 协议，所以，使用起来也是比较方便，它只有七种操作：
GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS。每一次操作都会触发表征状态转移。

一个理想的、完全满足 REST 风格的系统应该满足一下六大原则：

- 客户端与服务端分离（例如，前端代码驱动服务端渲染的 SSR）
- 无状态（服务端不保存用户当前状态）
- 可缓存（客户端或中间服务器缓存部分服务器应答）
- 分层系统（客户端可经过多个中间服务器连接到最终服务器，典型应用为 CDN）
- 统一接口（使用 HTTP 提供的操作，建议使用资源 ID 访问资源）
- 按需代码（可选原则，可执行的代码由服务端发往客户端，并在客户端执行和销毁）

REST 风格具有学习成本低、按资源分层方便、基于 HTTP 协议等优点。
但是，过于抽象不太符合人类思维习惯是它的一个缺点。

以上是理论，下面讲实践。

衡量一个“服务有多么 REST”的成熟度模型规定：

- 第 0 级：完全不 REST；
- 第 1 级：开始引入资源的概念；
- 第 2 级：引入统一接口，映射到 HTTP 协议的方法上；
- 第 3 级：超文本驱动。

具体案例参考 [RMM 成熟度](https://icyfenix.cn/architect-perspective/general-architecture/api-style/rest.html#rmm-%E6%88%90%E7%86%9F%E5%BA%A6)。
在这个案例中，我们需要思考：**应该如何设计一个资源的上下级关系**，让服务端的 API 和客户端完全解耦，以应对不断变化的需求。

REST 风格也有一些局限性，值得我们注意：

- 面向资源的编程思想只适合做 CRUD，面向过程、面向对象编程才能处理真正复杂的业务逻辑；
- REST 与 HTTP 完全绑定，不适合应用于要求高性能传输的场景中；
- REST 不利于事务支持；
- REST 没有传输可靠性支持；
- REST 缺乏对资源进行“部分”和“批量”的处理能力。

最后，考虑使用哪种方式来编程取决于我们的场景：

- 面向过程编程时，为什么要以算法和处理过程为中心？输入数据、输出结果？（计算机世界的交互方式）
- 面向对象编程时，为什么要将数据和行为统一起来，封装成对象？（现实世界的交互方式）
- 面向资源编程时，为什么要将资源作为抽象的主体，把行为看做统一的接口？（网络世界的交互方式）
