========
面向对象
========

什么是面向对象编程
------------------

面向对象编程可以看作一种在程序中包含各种 **独立** 而又 **互相调用** 的对象的思想 [cite_ref-1]_。
这种特点非常副歌

面向对象编程（OOP）

1. 万物皆为对象。（可以存储数据、可以执行操作）
2. 程序是对象的集合，它们通过发送消息来告知彼此所要做的。（方法调用）
3. 每个对象都有自己的由其他对象所构成的存储。（通过 import 实现）
4. 每个对象都拥有其类型。
5. 某一特定类型的所有对象都可以接收同样的消息。（多态）

.. note:: 
    
    这里似乎表述的并不清楚，需要参考其他教材。
    早期的编程语言：建立起在机器模型和实际待解问题的模型之间的关联。比较难以维护。
    面向对象方式：将问题空间中的元素及其在解空间的表示称为“对象”。程序可以通过添加新类型的对象使自身适用于某个特定问题。


每个对象都有一个接口
--------------------

强调一个接口，是因为每个编译单元 [1]_ 只能有一个 public 类。

发送消息 = 调用对象的方法。

.. rubric:: 注

.. [1] 一个编译单元对应一个 .java 文件。

每个对象都提供服务
------------------

当正在试图开发或理解一个程序设计时，最好的方法之一是：将对象想象为“服务提供者”。

程序本身将向用户提供服务，它通过调用其他对象的服务来实现这一目的。

你的目标就是去创建（或者最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。


被隐藏的具体实现
----------------

通过访问权限控制关键字“privated”，这样做会更加安全，防止客户端程序员访问越界内容。


复用具体实现
------------

组合：直接使用该类的一个对象，它比继承更加灵活

灵活指的是：

- 新类的成员对象通常都被声明为 private。
- 这使得可以在不干扰客户端代码的情况下，修改这些成员。
- 也可以在运行时修改这些成员对象，以实现动态修改程序的行为。


继承
-----

.. note:: 

  - 是一个（is-a）用于判断一个类是否继承自另一个类。例如：一个圆形就是一个几何形状；
  - 像是一个（is-like-a）一个类和另一个类是否继承自同一个父类。例如：热力泵像是一个空调。

.. tip:: 父类 = 基类 = 超类；子类 = 继承类 = 导出类。


伴随多态的可互换对象
--------------------

多态的特性提高了代码的扩展能力。

**后期绑定的执行过程：**

为了执行后期绑定，Java 使用一小段特殊的代码？来替代绝对的地址调用。这段代码使用在对象中存储的信息来计算方法体的地址。根据这一小段代码的内容，每一个对象都可以具有不同的行为表现。当向一个对象发送消息时，该对象就能知道对这条应该做什么。

.. note:: 后期绑定是面向对象编程语言的编译器产生的函数调用。

**前期绑定的执行过程（解释不清晰，需要修改）：**

C++ 需要使用 virtual 关键字明确地声明希望某个方法具备后期绑定属性所带来的灵活性。

.. note:: 前期绑定是非面向对象编程的编译器产生的函数调用。

单根继承结构
------------

Java 中所有的类都继承自 Object 。

单根继承结构有利于垃圾回收器的实现（为什么）。


容器
-----

容器也被称为集合。

应用场景：

- 不知道需要多少个对象；
- 不知道存活多长时间；
- 不知道需要多少空间来创建对象，运行时才知道。

容器类型：

- List（用于存储序列）
- Map（关联数组，用于建立对象之间的关联）
- Set（每种对象类型只持有一个）
- 队列
- 树
- 堆栈

.. note:: 这些都是构件。


参数化类型机制：泛型：

可以存储 Object 的容器可以存储任何东西，这使得容器很容易被复用。将对象存储到 Object 类型的容器中将会发生（泛型 [2]_ 过程），如下：

- 存对象时，向上转型为 Object 是安全的，但是会丢失身份。
- 取对象时，获得 Object 对象的引用（向下转型时需要强制类型转换以得到正确的类型，向下转型不安全）。

Java SE5 的特性中增加了参数化类型（在 Java 中它称为泛型）。解决了向下转型的不安全问题（为什么呢？）。

.. code-block:: java

    ArrayList<Shape> shapes = new ArrayList<Shape>();

.. rubric:: 注

.. [2] 用尖括号包含类型信息表示 **泛型** ，泛型是类型安全的容器，泛型解决了向下转型带来的不安全问题。

对象的创建和生命期
--------------------

如何实现更快的执行速度（C++ 是这样做的）：

- 编译时确定对象的存储空间和声明周期（将对象置于堆栈或静态存储区域）
- 优先考虑存储空间的分配和释放
- 缺点：牺牲了灵活性（必须在编写程序时知道对象数量、生命周期、类型信息）

解决灵活性，牺牲执行速度（Java 是这样做的）：

- 运行时确定对象数量、生命周期和类型信息（在堆（内存池）中动态地创建对象）
- 需要大量时间在堆中分配存储空间
- 垃圾回收器负责释放存储空间

.. note:: 

    - 在堆中分配空间的时间大于在堆栈中分配空间的时间
    - 在堆栈中分配和释放空间，只需要将栈顶指针向下或向上移动
    - 创建堆存储空间的时间依赖于存储机制的设计

异常处理
---------

- 异常是一种对象，它从错误地点被“抛出”，并被专门设计用来处理特定类型错误的响应的异常处理器“捕获”。
- 异常处理就像是与程序正常执行路径并行的、在错误发生时执行的另一条路径。
- 它是另一条完全分离的执行路径，所以它不会干扰正常的执行代码。
- 异常不能被忽略，所以它保证一定会在某处得到处理。

并发编程
-----------

把问题切分成多个可独立运行的部分（任务），从而提高程序的响应能力。在程序中，这些彼此独立运行的部分称之为线程，上述概念被称为“并发”。并发最常见的例子就是用户界面。

并发执行过程：

1. 程序停下正在做的工作，转而处理其他问题
2. 然后再返回主进程

原先实现并发的思路：

1. 编写中断服务程序（硬件中断触发主进程挂起）
2. 隐患：难度大、不能移植

后来实现并发的思路：

1. 把问题切分成多个可独立运行的部分（任务）
2. 彼此独立运行的部分称为线程
3. 为线程分配执行时间（单处理器）
4. 为线程指派不同的处理器（多处理器）
5. 隐患：共享资源

Java 与 Internet
---------------------

Web 是一个巨型客户/服务器系统
        
服务器是指：

- 中央信息存储池：通常指数据库
- 分发信息的软件
- 信息与软件所驻留的机器或集群

客户端是指：

- 驻留在用户机器上的软件
- 用于和服务器通信，获取信息、处理信息、显示信息

事务处理是指：

- 客户插入新数据不会覆盖另一个客户插入的新数据
- 插入的过程中数据不会丢失？（这话有点问题）

最小化延迟的手段：

- 将数据分散给客户端机器处理
- 使用中间件，将负载分散给服务端的其他机器（中间件提高了可维护性）


客户端编程：

- 方法一：通用网关接口（CGI）负责传递用户提交的动作，提交内容告诉 CGI 如何处理提交动作。如果一个程序应用了 CGI 那么会在地址栏看到 cgi-bin 字样，构建于 CGI 程序之上的程序复杂、难以维护、响应时间长。
- 方法二：客户端编程，Web 浏览器负责执行一部分工作

1. 通过插件（plug-in）
2. 通过脚本语言（scripting language）
3. 通过 Java Applet 完成并发、数据库访问、网络编程、分布式计算
4. 通过 .NET 和 C# （.NET 平台相当于 Java 虚拟机和 Java 类库，C# 与 Java 类似）
5. 通过 Internet 和 Intranet （Intranet 是企业内部网，更安全）


服务器端编程：当业务需求涉及对数据库的修改时，这些数据库请求必须通过服务器端的某些代码来处理，这就是服务器端编程。

1. 通过 CGI 实现
2. 通过 servlet 及其衍生物 JSP 实现


用引用操纵对象
--------------

必须由你创建所有对象
--------------------

存储到什么地方
~~~~~~~~~~~~~~~

寄存器：位于处理器内部，最快，但是数量有限。

堆栈：位于 RAM 中，通过堆栈指针分配和释放空间，创建时知道生命周期。

堆：位于 RAM 中，通用内存池，用于存储 Java 对象，不知道对象的生命周期。

常量存储：位于程序代码内部，安全，且永远不会被改变。

非 RAM 对象：完全存活于程序之外，可以不受程序的控制，程序没有运行时也可以存在，如流对象 [3]_ 和持久化对象 [4]_ 。

.. rubric:: 注

.. [3] 流对象：对象转化为字节流，通常发送给另一台机器。
.. [4] 持久化对象：对象存放于磁盘上，JDBC 和 Hibernate 提供轻量级持久化支持。

数据类型
~~~~~~~~~~~~

基本数据类型
^^^^^^^^^^^^^

.. csv-table:: 基本数据类型
    :header: "基本类型", "大小", "最小值", "最大值", "包装器类型", "默认值"

    "boolean", "--", "--", "--", "Boolean", "false"
    "char", "16-bit", "Unicode :math:`0`", "Unicode :math:`2^{16}-1`", "Character", "'\u0000'(null)"
    "byte", "8-bit", ":math:`-128`", ":math:`+127`", "Byte", "(byte)0"
    "short", "16-bit", ":math:`-2^{15}`", ":math:`+2^{15}-1`", "Short", "(short)0"
    "int", "32-bit", ":math:`-2^{31}`", ":math:`+2^{31}-1`", "Integer", "0"
    "long", "64-bit", ":math:`-2^{63}`", ":math:`+2^{63}-1`", "Long", "0L"
    "float", "32-bit", "IEEE754", "IEEE754", "Float", "0.0f"
    "double", "64-bit", "IEEE754", "IEEE754", "Double", "0.0d"
    "void", "--", "--", "--", "Void", ""

高精度数字
^^^^^^^^^^^

- ``BigInteger``
- ``BigDecimal``

永远不需要销毁对象
-------------------

作用域
~~~~~~~

以花括号为边界

.. code-block:: java

    {
        int x = 12;
        // Only x is avaliable
        {
            int q = 96;
            // Both x & q avaliable
        }
        // Only x is avaliable
        // q is "out of scope"
    }

对象的作用域
~~~~~~~~~~~~~

对象的生命周期并不受花括号限制，可以存活于作用域之外。

.. code-block:: java

    {
        String s = new String("a string");
    } // End of scope

在花括号结束时，变量 s 就消失了，但是 s 指向的 String 对象仍然占据内存空间。String 对象只要你需要，就会一直存在， **直到没有指向该对象的引用时（可能是有一个计数器来记录有多少个指向该对象的引用）** ，由垃圾回收器回收。

创建新的数据类型：类
--------------------

字段和方法
~~~~~~~~~~

- 字段：或称数据成员
- 方法：或称成员函数

方法、参数和返回值
------------------

调用方法的行为通常被称为 ``发送消息给对象`` 。

参数列表
~~~~~~~~

基本数据类型之间进行 ``值传递`` ，对象作为参数实际上是 ``引用传递`` 。

有时候，我们不确定需要传递的参数的个数，那么可以参考 :ref:`可变参数列表的使用方法 <variable-argument-list>` 。

构建一个 Java 程序
-------------------

运用其他构件
~~~~~~~~~~~~

- 反转域名后，句点就用来代表子目录的划分
- 配置 ``CLASSPATH`` 以显式声明搜索路径
- 使用 ``import`` 关键字导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包含方法和数据，但 Java 中所有的代码都必须写在类里）
- 搜索类库的完整路径为 ``%CLASSPATH%\{import后面的路径}`` 

你的第一个 Java 程序
~~~~~~~~~~~~~~~~~~~~

.. code-block:: java

    public class HelloDate {
        public static void main(String[] args) {
            System.out.println("Hello, it's: ");
            System.out.println(new Date());
        }
    }

注释和嵌入式文档
-----------------

注释文档 javadoc
~~~~~~~~~~~~~~~~~

只能为 public 和 protected 成员进行文档注释

语法
^^^^^

- 注释文档以 ``/**`` 开始，以 ``*/`` 结束
- 独立文档标签以 ``@`` 开头
- 行内文档标签也是以 ``@`` 开头，但要括在花括号内

一些标签示例
^^^^^^^^^^^^

- ``@see`` 引用其他类，查看更多
- ``{@link package.class#member label}`` 类似于 ``@see``，位于行内，label 为超链接文本
- ``{@docRoot}`` 产生到文档根目录的相对路径，用于文档树页面的显式超链接
- ``{@inheritDoc}`` 从当前类的最直接基类中继承相关文档到当前文档的注释中
- ``@version version-infomation`` 使用 ``javadoc -version`` 提取出 HTML 文档中的版本信息
- ``@author author-infomation`` 使用 ``javadoc -author`` 提取出 HTML 文档中的作者信息
- ``@since`` 指定程序代码最早使用的 JDK 版本
- ``@param parameter-name description`` 
- ``@return description`` 
- ``@throws fully-qualified-class-name description`` 
- ``@deprecated`` 指出一些旧特性已由新特性取代，建议用户不要使用旧特性，因为旧特性将来可能会被删除

嵌入式 HTML
~~~~~~~~~~~

在注释中使用 HTML 标签即可

用法举例
~~~~~~~~

.. code-block:: java

    //: object/HelloDate.java
    import java.util.*;

    /** The first Thinking in Java example program.
    * Displays a string and today's date.
    * @author Bruce Eckel
    * @author www.MindView.net
    * @version 4.0
    */
    public class HelloDate {
        /** Entry point to class & application.
        * @param args array of string arguments
        * @throws exceptions No exceptions thrown
        */
        public static void main(String[] args) {
            System.out.println("Hello, it's: ");
            System.out.println(new Date());
        }
    } /* Output: (55% match)
    Hello, it's:
    Wed Oct 05 14:39:36 MDT 2005
    *///:~


编码风格：驼峰式
-----------------

- methodName
- ClassName

.. rubric:: 参考资料

.. [cite_ref-1] Object-oriented programming https://en.wikipedia.org/wiki/Object-oriented_programming